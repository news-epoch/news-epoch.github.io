{"meta":{"title":"卫大人的杂乱博客","subtitle":"","description":"客官，打尖已久，何时离店，把账结了？","author":"卫大人","url":"https://news-epoch.github.io","root":"/"},"pages":[{"title":"","date":"2025-07-02T09:53:10.799Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"about/index.html","permalink":"https://news-epoch.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2025-07-02T09:53:10.799Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"archives/index.html","permalink":"https://news-epoch.github.io/archives/index.html","excerpt":"","text":"123layout: archivetitle: &lt;%= page.archive.title %&gt;archive_type: &lt;%= page.archive.type %"},{"title":"所有分类","date":"2025-07-02T09:53:10.799Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"categories/index.html","permalink":"https://news-epoch.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-07-02T09:53:10.874Z","updated":"2025-07-02T09:53:10.874Z","comments":true,"path":"tags/index.html","permalink":"https://news-epoch.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"教你如何理解分布式CAP和BASE理论","slug":"教你如何理解分布式CAP和BASE理论","date":"2025-07-02T08:58:46.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2025/07/02/教你如何理解分布式CAP和BASE理论/","permalink":"https://news-epoch.github.io/2025/07/02/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8FCAP%E5%92%8CBASE%E7%90%86%E8%AE%BA/","excerpt":"","text":"学习分布式第一件事就是要知道 什么是CAP &amp; BASE 理论，因为这两个理论是学习分布式的前置基础。 CAP 理论CAP 理论 &#x2F; 定理起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 布鲁尔定理（Brewer’s theorem） 1 简介CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。 在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个： 一致性（Consistency） : 所有节点访问同一份最新的数据副本 可用性（Availability）：非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。 分区容错性（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。 现在就有个额外的问题了，什么是网络分区呢？ 分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 网络分区。 2 所谓的 “3选2” 又如何解释呢？包括我在呢，之前解释3选2其实都只用一句话就解释了“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。但是这个其实是不正确的。而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。 当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。 这里就有问题了，为啥不可能选择 CA 架构呢？ 举个例子：若系统出现 “分区”，系统中的某个节点在进行写操作。为了保证 C(一致性)， 必须要禁止其他节点的读写操作（这个会导致其他节点无法按时返回合理的响应），这就和 A（可用性） 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了（会存在类似于幻读的情况）。 再举个比较简单的例子：分布式数据库系统Redis集群，它们通常通过复制保持数据一致。键为 balance，初始值为100。 正常情况：无网络分区- 客户端写入：将 balance 更新为200。 - Node A 接受写入，并同步到 Node B。 - 两者都更新为200，数据一致。- 客户端读取：从 Node A 或 Node B 读取，都返回200。- 这里C和A同时满足：数据一致，且请求都能响应。 网络分区发生（P发生）网络故障导致 Node A 和 Node B 无法通信。系统被分成两个分区： 分区1：Node A（可访问） 分区2：Node B（可访问） 情况1：系统优先保证可用性（A）—— 选择AP 客户端向 Node A 写入：将 balance 更新为300。Node A 本地更新为300，但由于分区，无法同步到 Node B。 同时，客户端向 Node B 写入：将 balance 更新为400。Node B 本地更新为400。 客户端读取： 从 Node A 读取：返回300（最新值）。 从 Node B 读取：返回400（最新值）。 结果：系统可用（所有请求都响应），但数据不一致（Node A 和 Node B 的值不同）。C被牺牲。 情况2：系统优先保证一致性（C）—— 选择CP客户端向 Node A 写入：将 balance 更新为300 Node A 检测到网络分区，无法联系 Node B。为了保持一致性，它拒绝写入（返回错误如“系统不可用”）。 客户端向 Node B 写入：同样被拒绝。 客户端读取： 如果系统允许读取，但必须确保数据一致（例如，只从主节点读），但由于分区，它可能返回错误或旧数据（如100）。 结果：系统一致（无冲突写入），但部分请求被拒绝。A被牺牲。 因此，分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。 比如Zookeeper是CP架构，Eureka是CA架构，Nacos不仅支持AP，也支持CP。 但是如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。 3 CAP 实际应用案例这里以注册中心来探讨一下 CAP 的实际应用。 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos…。 ZooKeeper 保证的是 CP。 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。 Eureka 保证的则是 AP。 Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。 Nacos有双模式： AP 模式：服务注册与发现场景(允许实例动态扩缩容，短暂不一致不影响整体可用性) CP 模式：配置文件管理场景(要求全局一致，避免因配置错误导致系统故障) 4 如何选择用CA还是CP呢？比如分布式锁？这里实现分布式锁的方式选取了三种： 基于数据库实现分布式锁 基于redis实现分布式锁 基于zookeeper实现分布式锁 基于数据库实现分布式锁这种方式强依赖于数据库的可用性，这种方式基本不在CAP的一个讨论范围。 4.1 基于redis实现分布式锁实现方式： 12setnx key value Expire_time 获取到锁 返回 1 ， 获取失败 返回 0 为了解决数据库锁的无主从切换的问题，可以选择redis集群，或者是 sentinel 哨兵模式，实现主从故障转移，当master节点出现故障，哨兵会从slave中选取节点，重新变成新的master节点。 哨兵模式故障转移是由sentinel集群进行监控判断，当maser出现异常即复制中止，重新推选新slave成为master，sentinel在重新进行选举并不在意主从数据是否复制完毕具备一致性。 所以redis的复制模式是属于AP的模式。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据，这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务同时获取得两把锁。 上述的问题其实并不是redis的缺陷，只是redis采用了AP模型，它本身无法确保我们对一致性的要求。 4.2 所以能否使用redis作为分布式锁？能不能使用redis作为分布式锁，这个本身就不是redis的问题，还是取决于业务场景，我们先要自己确认我们的场景是适合 AP 还是 CP ， 如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，redis提供给我们高性能的AP模型是非常适合的，但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻在一种更加适合的 CP 模型。 4.3 基于zookeeper实现分布式锁redis其实无法确保数据的一致性，先来看zookeeper是否合适作为我们需要的分布式锁，首先结论：zookeeper的模式是CP模型，也就是说，当zookeeper锁提供给我们进行访问的时候，在zookeeper集群中能确保这把锁在zookeeper的每一个节点都存在。 具体实现就待我再学习学习，或者各位老师，去找找具体的资料。 BASE 理论1 简介 BASE 是 Basically Available（基本可用）、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。 2 BASE 理论的核心思想即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体 “主要可用”。 BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。 再CAP理论中，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。 3 BASE理论三要素 3.1.1 基本可用 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 3.1.2 软状态 软状态指允许系统中的数据存在中间状态（CAP 理论中的数据不一致），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 3.1.3 最终一致性最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"还在纠结Kafka和RabbitMQ用哪个？","slug":"还在纠结Kafka和RabbitMQ用哪个？","date":"2025-06-28T13:01:44.000Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"2025/06/28/还在纠结Kafka和RabbitMQ用哪个？/","permalink":"https://news-epoch.github.io/2025/06/28/%E8%BF%98%E5%9C%A8%E7%BA%A0%E7%BB%93Kafka%E5%92%8CRabbitMQ%E7%94%A8%E5%93%AA%E4%B8%AA%EF%BC%9F/","excerpt":"","text":"1 前言经常有人问我 有个 xx 需求，我应该用 Kafka 还是 RabbitMQ ？ 这个问题很常见，而且很多人对二者的选择也把握不好。 所以我决定写篇文章来详细说一下：Kafka 和 RabbitMQ 的区别，适用于什么场景？ 同时，这个问题在面试中也经常问到。 下面我会通过 6 个场景，来对比分析一下 Kafka 和 RabbitMQ 的优劣。 2 一、消息的顺序有这样一个需求：当订单状态变化的时候，把订单状态变化的消息发送给所有关心订单变化的系统。 订单会有创建成功、待付款、已支付、已发货的状态，状态之间是单向流动的。 ​ 好，现在我们把订单状态变化消息要发送给所有关心订单状态的系统上去，实现方式就是用消息队列. ​ 在这种业务下，我们最想要的是什么？ 消息的顺序：对于同一笔订单来说，状态的变化都是有严格的先后顺序的。 吞吐量：像订单的业务，我们自然希望订单越多越好。订单越多，吞吐量就越大。 在这种情况下，我们先看看 RabbitMQ 是怎么做的。 首先，对于发消息，并广播给多个消费者这种情况，RabbitMQ 会为每个消费者建立一个对应的队列。也就是说，如果有 10 个消费者，RabbitMQ 会建立 10 个对应的队列。然后，当一条消息被发出后，RabbitMQ 会把这条消息复制 10 份放到这 10 个队列里。 ​ 当 RabbitMQ 把消息放入到对应的队列后，我们紧接着面临的问题就是，我们应该在系统内部启动多少线程去从消息队列中获取消息。 如果只是单线程去获取消息，那自然没有什么好说的。但是多线程情况，可能就会有问题了…… RabbitMQ 有这么个特性，它在官方文档就声明了自己是不保证多线程消费同一个队列的消息，一定保证顺序的。而不保证的原因，是因为多线程时，当一个线程消费消息报错的时候，RabbitMQ 会把消费失败的消息再入队，此时就可能出现乱序的情况。 ​ T0 时刻，队列中有四条消息 A1、B1、B2、A2。其中 A1、A2 表示订单 A 的两个状态：待付款、已付款。B1、B2 也同理，是订单 B 的待付款、已付款。 到了 T1 时刻，消息 A1 被线程 1 收到，消息 B1 被线程 2 收到。此时，一切都还正常。 到了 T3 时刻，B1 消费出错了，同时呢，由于线程 1 处理速度快，又从消息队列中获取到了 B2。此时，问题开始出现。 到了 T4 时刻，由于 RabbitMQ 线程消费出错，可以把消息重新入队的特性，此时 B1 会被重新放到队列头部。所以，如果不凑巧，线程 1 获取到了 B1，就出现了乱序情况，B2 状态明明是 B1 的后续状态，却被提前处理了。 所以，可以看到了，这个场景用 RabbitMQ，出现了三个问题： 为了实现发布订阅功能，从而使用的消息复制，会降低性能并耗费更多资源 多个消费者无法严格保证消息顺序 大量的订单集中在一个队列，吞吐量受到了限制 那么 Kafka 怎么样呢？Kafka 正好在这三个问题上，表现的要比 RabbitMQ 要好得多。 首先，Kafka 的发布订阅并不会复制消息，因为 Kafka 的发布订阅就是消费者直接去获取被 Kafka 保存在日志文件中的消息就好。无论是多少消费者，他们只需要主动去找到消息在文件中的位置即可。 其次，Kafka 不会出现消费者出错后，把消息重新入队的现象。 最后，Kafka 可以对订单进行分区，把不同订单分到多个分区中保存，这样，吞吐量能更好。 所以，对于这个需求 Kafka 更合适。 3 二、消息的匹配我曾经做过一套营销系统。这套系统中有个非常显著的特点，就是非常复杂非常灵活地匹配规则。 比如，要根据推广内容去匹配不同的方式做宣传。又比如，要根据不同的活动去匹配不同的渠道去做分发。 总之，数不清的匹配规则是这套系统中非常重要的一个特点。 ​ 首先，先看看 RabbitMQ 的，你会发现 RabbitMQ 是允许在消息中添加 routing_key 或者自定义消息头，然后通过一些特殊的 Exchange，很简单的就实现了消息匹配分发。开发几乎不用成本。 而 Kafka 呢？如果你要实现消息匹配，开发成本高多了。 首先，通过简单的配置去自动匹配和分发到合适的消费者端这件事是不可能的。 其次，消费者端必须先把所有消息不管需要不需要，都取出来。然后，再根据业务需求，自己去实现各种精准和模糊匹配。可能因为过度的复杂性，还要引入规则引擎。 这个场景下 RabbitMQ 扳回一分。 4 三、消息的超时在电商业务里，有个需求：下单之后，如果用户在 15 分钟内未支付，则自动取消订单。 你可能奇怪，这种怎么也会用到消息队列的？ 我来先简单解释一下，在单一服务的系统，可以起个定时任务就搞定了。 但是，在 SOA 或者微服务架构下，这样做就不行了。因为很多个服务都关心是否支付这件事，如果每种服务，都自己实现一套定时任务的逻辑，既重复，又难以维护。 在这种情况下，我们往往会做一层抽象：把要执行的任务封装成消息。当时间到了，直接扔到消息队列里，消息的订阅者们获取到消息后，直接执行即可。 希望把消息延迟一定时间再处理的，被称为延迟队列。 对于订单取消的这种业务，我们就会在创建订单的时候，同时扔一个包含了执行任务信息的消息到延迟队列，指定 15 分钟后，让订阅这个队列的各个消费者，可以收到这个消息。随后，各个消费者所在的系统就可以去执行相关的扫描订单的任务了。 ​ 4.1 RabbitMQ 和 Kafka 消息队列如何选？先看下 RabbitMQ 的。 RabbitMQ 的消息自带手表，消息中有个 TTL 字段，可以设置消息在 RabbitMQ 中的存放的时间，超时了会被移送到一个叫死信队列的地方。 所以，延迟队列 RabbitMQ 最简单的实现方式就是设置 TTL，然后一个消费者去监听死信队列。当消息超时了，监听死信队列的消费者就收到消息了。 不过，这样做有个大问题：假设，我们先往队列放入一条过期时间是 10 秒的 A 消息，再放入一条过期时间是 5 秒的 B 消息。 那么问题来了，B 消息会先于 A 消息进入死信队列吗？ 答案是否定的。B 消息会优先遵守队列的先进先出规则，在 A 消息过期后，和其一起进入死信队列被消费者消费。 在 RabbitMQ 的 3.5.8 版本以后，官方推荐的 rabbitmq delayed message exchange 插件可以解决这个问题。 用了这个插件，我们在发送消息的时候，把消息发往一个特殊的 Exchange。 同时，在消息头里指定要延迟的时间。 收到消息的 Exchange 并不会立即把消息放到队列里，而是在消息延迟时间到达后，才会把消息放入。 ​ 再看下 Kafka 的： ​ Kafka 要实现延迟队列就很麻烦了。 你先需要把消息先放入一个临时的 topic。 然后得自己开发一个做中转的消费者。让这个中间的消费者先去把消息从这个临时的 topic 取出来。 取出来，这消息还不能马上处理啊，因为没到时间呢。也没法保存在自己的内存里，怕崩溃了，消息没了。所以，就得把没有到时间的消息存入到数据库里。 存入数据库中的消息需要在时间到了之后再放入到 Kafka 里，以便真正的消费者去执行真正的业务逻辑。 …… 想想就已经头大了，这都快搞成调度平台了。再高级点，还要用时间轮算法才能更好更准确。 这次，RabbitMQ 上那一条条戴手表的消息，才是最好的选择。 5 四、消息的保持在微服务里，事件溯源模式是经常用到的。如果想用消息队列实现，一般是把事件当成消息，依次发送到消息队列中。 事件溯源有个最经典的场景，就是事件的重放。简单来讲就是把系统中某段时间发生的事件依次取出来再处理。而且，根据业务场景不同，这些事件重放很可能不是一次，更可能是重复 N 次。 假设，我们现在需要一批在线事件重放，去排查一些问题。 RabbitMQ 此时就真的不行了，因为消息被人取出来就被删除了。想再次被重复消费？对不起。 而 Kafka 呢，消息会被持久化一个专门的日志文件里。不会因为被消费了就被删除。 所以，对消息不离不弃的 Kafka 相对用过就抛的 RabbitMQ，请选择 Kafka。 6 五、消息的错误处理很多时候，在做记录数据相关业务的时候，Kafka 一般是不二选择。不过，有时候在记录数据吞吐量不大时，我自己倒是更喜欢用 RabbitMQ。 原因就是 Kafka 有一个我很不喜欢的设计原则： 当单个分区中的消息一旦出现消费失败，就只能停止而不是跳过这条失败的消息继续消费后面的消息。即不允许消息空洞。 只要消息出现失败，不管是 Kafka 自身消息格式的损坏，还是消费者处理出现异常，是不允许跳过消费失败的消息继续往后消费的。 所以，在数据统计不要求十分精确的场景下选了 Kafka，一旦出现了消息消费问题，就会发生项目不可用的情况。这真是徒增烦恼。 而 RabbitMQ 呢，它由于会在消息出问题或者消费错误的时候，可以重新入队或者移动消息到死信队列，继续消费后面的，会省心很多。 坏消息就像群众中的坏蛋那样，Kafka 处理这种坏蛋太过残暴，非得把坏蛋揪出来不行。相对来说，RabbitMQ 就温柔多了，群众是群众，坏蛋是坏蛋，分开处理嘛。 7 六、消息的吞吐量Kafka 是每秒几十万条消息吞吐，而 RabbitMQ 的吞吐量是每秒几万条消息。 其实，在一家公司内部，有必须用到 Kafka 那么大吞吐量的项目真的很少。大部分项目，像 RabbitMQ 那样每秒几万的消息吞吐，已经非常够了。 在一些没那么大吞吐量的项目中引入 Kafka，我觉得就不如引入 RabbitMQ。 为什么呢？ 因为 Kafka 为了更好的吞吐量，很大程度上增加了自己的复杂度。而这些复杂度对项目来说，就是麻烦，主要体现在两个方面： 1、配置复杂、维护复杂 Kafka 的参数配置相对 RabbitMQ 是很复杂的。比如：磁盘管理相关参数，集群管理相关参数，ZooKeeper 交互相关参数，Topic 级别相关参数等，都需要一些思考和调优。 另外，Kafka 本身集群和参与管理集群的 ZooKeeper，这就带来了更多的维护成本。Kafka 要用好，你要考虑 JVM，消息持久化，集群本身交互，以及 ZooKeeper 本身和它与 Kafka 之间的可靠和效率。 2、用好，用对存在门槛 Kafka 的 Producer 和 Consumer 本身要用好用对也存在很高的门槛。 比如，Producer 消息可靠性保障、幂等性、事务消息等，都需要对 KafkaProducer 有深入的了解。 而 Consumer 更不用说了，光是一个日志偏移管理就让一大堆人掉了不少头发。 相对来说，RabbitMQ 就简单得多。你可能都不用配置什么，直接启动起来就能很稳定可靠地使用了。就算配置，也是寥寥几个参数设置即可。 所以，大家在项目中引入消息队列的时候，真的要好好考虑下，不要因为大家都鼓吹 Kafka 好，就无脑引入。 8 总结可以看到，如果我们要做消息队列选型，有两件事是必须要做好的： 列出业务最重要的几个特点 深入到消息队列的细节中去比较 等我们对这些中间件的特点非常熟悉之后，甚至可以把业务分解成不同的子业务，再根据不同的子业务的特征，引入不同的消息队列，即消息队列混用。这样，我们就可能会最大化我们的获益，最小化我们的成本。 说了这么多，其实还有很多 Kafka 和 RabbitMQ 的比较没有说，比如二者集群的区别，占用资源多少的比较等。以后有机会可以再提提。 总之，期待大家看完这篇文章后，能对 Kafka 和 RabbitMQ 的区别有了更细节性的了解。 最后，分享一个网上的比较全的对比图： ​ ​ ​ ​","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_中间件","slug":"计算机-程序语言-中间件","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Linux更换内核，grub.cfg没有对应版本内核的menuentry选项的解决办法","slug":"Linux更换内核，grub.cfg没有对应版本内核的menuentry选项的解决办法","date":"2025-05-23T04:34:38.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2025/05/23/Linux更换内核，grub.cfg没有对应版本内核的menuentry选项的解决办法/","permalink":"https://news-epoch.github.io/2025/05/23/Linux%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8%EF%BC%8Cgrub.cfg%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E5%86%85%E6%A0%B8%E7%9A%84menuentry%E9%80%89%E9%A1%B9%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"在服务器上装了新的内核，想指定默认从新内核启动，但是某些发行版的&#x2F;boot&#x2F;grub2&#x2F;grub.cfg里面，没有找到各个内核的menuentry选项。这该怎么办呢？ 方法就是，修改&#x2F;etc&#x2F;default&#x2F;grub这个文件，把里面的GRUB_ENABLE_BLSCFG这个参数给改为false（或者注释掉） 接着再grub2-mkconfig -o &#x2F;boot&#x2F;grub2&#x2F;grub.cfg即可 grub2-mkconfig：是一个用于生成和更新 GRUB 2 配置文件的命令。它会扫描系统中的内核和操作系统，并生成一个新的 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg 文件。 12awk -F\\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfggrub2-set-default 0","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_操作系统_Linux","slug":"计算机-操作系统-Linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux/"},{"name":"计算机_操作系统_linux","slug":"计算机-操作系统-linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-linux/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://news-epoch.github.io/tags/WireGuard/"}]},{"title":"MyBatis---防止sql注入---mybatis中♯{}是怎么防止sql注入的？","slug":"MyBatis---防止sql注入---mybatis中♯{}是怎么防止sql注入的？","date":"2025-05-20T09:31:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2025/05/20/MyBatis---防止sql注入---mybatis中♯{}是怎么防止sql注入的？/","permalink":"https://news-epoch.github.io/2025/05/20/MyBatis---%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5---mybatis%E4%B8%AD%E2%99%AF%7B%7D%E6%98%AF%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84%EF%BC%9F/","excerpt":"","text":"在 MyBatis 中，#&#123;&#125; 能够防止 SQL 注入的核心原因是它使用了 预编译（PreparedStatement） 机制。预编译机制会将 SQL 语句和参数分开处理，确保参数值不会被解释为 SQL 代码。下面我们通过一个具体的例子来说明 #&#123;&#125; 是如何防止 SQL 注入的。 SQL 注入的原理SQL 注入是一种常见的安全漏洞，攻击者通过在输入中插入恶意的 SQL 代码，篡改原始的 SQL 语句，从而执行非法的数据库操作。例如： 1SELECT * FROM users WHERE username = &#x27;admin&#x27; AND password = &#x27;password&#x27;; 如果用户输入的 password 是 &#39; OR &#39;1&#39;=&#39;1，那么最终的 SQL 语句会变成： 1SELECT * FROM users WHERE username = &#x27;admin&#x27; AND password = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;; 这条语句会绕过密码验证，返回所有用户数据，因为 &#39;1&#39;=&#39;1&#39; 永远为真。 #&#123;&#125; 防止 SQL 注入的原理当 MyBatis 使用 #&#123;&#125; 时，它会将 SQL 语句和参数分开处理： SQL 语句：使用 PreparedStatement 预编译。 参数值：通过 PreparedStatement 的 setString、setInt 等方法安全地传递给数据库。 这种机制确保了参数值不会被解释为 SQL 代码，从而防止 SQL 注入。 示例假设我们有以下 MyBatis 查询： 123&lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;&lt;/select&gt; 恶意输入 输入：username = &quot;admin&quot;，password = &quot;&#39; OR &#39;1&#39;=&#39;1&quot; 生成的 SQL：1SELECT * FROM users WHERE username = ? AND password = ? 执行过程： MyBatis 仍然使用 PreparedStatement 预编译 SQL 语句。 参数值 &quot;admin&quot; 和 &quot;&#39; OR &#39;1&#39;=&#39;1&quot; 会通过 setString 方法安全地传递给数据库。 最终执行的 SQL 语句是：1SELECT * FROM users WHERE username = &#x27;admin&#x27; AND password = &#x27;\\&#x27; OR \\&#x27;1\\&#x27;=\\&#x27;1&#x27;; 这里的 &#39; 被转义为 \\&#39;，因此恶意代码 &#39; OR &#39;1&#39;=&#39;1 不会被解释为 SQL 语法，而是作为一个普通的字符串值处理。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_框架_Mybatis","slug":"计算机-程序语言-Java-框架-Mybatis","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E6%A1%86%E6%9E%B6-Mybatis/"}]},{"title":"MyBatis 中 ♯{}和 ${} 的区别详解","slug":"MyBatis 中 ♯{}和 ${} 的区别详解","date":"2025-05-20T08:15:26.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2025/05/20/MyBatis 中 ♯{}和 ${} 的区别详解/","permalink":"https://news-epoch.github.io/2025/05/20/MyBatis%20%E4%B8%AD%20%E2%99%AF%7B%7D%E5%92%8C%20$%7B%7D%20%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"一、#&#123;&#125; 和 $&#123;&#125; 的基本概念#&#123;&#125; 作用：用于动态替换 SQL 语句中的参数。 处理方式：MyBatis 会将 #&#123;&#125; 转换为 JDBC 的 PreparedStatement 参数化查询。 特点： 使用预编译机制，防止 SQL 注入。 自动对参数进行转义处理。 适合传递参数值。 对于字符串会自动加 &#39; &#39;，如果传入参数为简单类型，可以写 $&#123;任意值&#125;，如果是对象，写的是$&#123;属性名&#125;底层解析的时候如果sql语句只包含 #{ } ，这条sql就会被解析成静态类型的语句，会把 #{ }转成 “ ? “，进行数据操作时调用JDBC进行赋值。 $&#123;&#125; 作用：用于直接替换 SQL 语句中的字符串。 处理方式：MyBatis 会将 ${} 直接拼接到 SQL 语句中，生成完整的 SQL 字符串。 特点： 直接拼接字符串，存在 SQL 注入风险。 不对参数进行转义处理。 适合动态表名、列名等非参数值场景。 不会自动加 ‘ ‘，如果传入参数为简单类型，那么必须写 $&#123;value&#125;，如果是对象，写的是$&#123;属性名&#125;；底层解析的时候只要sql语句包含 $&#123; &#125; ，在创建cofigration对象的时候，这条sql就会被解析成动态类型的语句，底层不会把 $&#123; &#125; 转成 “ ? “（不做处理），只会在使用Mapper接口代理对象进行数据操作的时候把#&#123; &#125;转成 “ ? “，之后再调用JDBC进行赋值，把$&#123; &#125;转成mapper接口的参数值，所以会存在SQL注入的问题。 二、工作原理1 #&#123;&#125; 的工作原理当 MyBatis 解析到 #&#123;&#125; 时，会将其转换为 JDBC 的 PreparedStatement 参数化查询。例如： 123&lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE username = #&#123;username&#125; AND password = #&#123;password&#125;&lt;/select&gt; MyBatis 会将上述 SQL 转换为： 12345PreparedStatement pstmt = connection.prepareStatement( &quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;);pstmt.setString(1, username);pstmt.setString(2, password); 这里的 ? 是 JDBC 的参数占位符，MyBatis 会通过 PreparedStatement 的 setString、setInt 等方法，将参数安全地传递给数据库。 2 $&#123;&#125; 的工作原理当 MyBatis 解析到 $&#123;&#125; 时，会直接将其替换为实际的参数值，并拼接到 SQL 语句中。例如： 123&lt;select id=&quot;getUser&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users WHERE username = &#x27;$&#123;username&#125;&#x27; AND password = &#x27;$&#123;password&#125;&#x27;&lt;/select&gt; 如果 username 的值为 admin，password 的值为 123456，MyBatis 会生成以下 SQL 语句： 1SELECT * FROM users WHERE username = &#x27;admin&#x27; AND password = &#x27;123456&#x27;; 三、适用场景(1). #&#123;&#125; 的适用场景：主要用于 动态参数值 的场景。(2). $&#123;&#125; 的适用场景： 动态表名、列名、排序字段等非参数值 的场景 动态表名： 123&lt;select id=&quot;getData&quot; resultType=&quot;map&quot;&gt; SELECT * FROM $&#123;tableName&#125;&lt;/select&gt; 动态列名： 123&lt;select id=&quot;getData&quot; resultType=&quot;map&quot;&gt; SELECT $&#123;columnName&#125; FROM users&lt;/select&gt; 动态排序字段： 123&lt;select id=&quot;getUsers&quot; resultType=&quot;User&quot;&gt; SELECT * FROM users ORDER BY $&#123;orderBy&#125; DESC&lt;/select&gt; 四、mybatis中#{}是怎么防止sql注入的MyBatis---防止sql注入---mybatis中♯{}是怎么防止sql注入的？","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_框架_Mybatis","slug":"计算机-程序语言-Java-框架-Mybatis","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E6%A1%86%E6%9E%B6-Mybatis/"}]},{"title":"idea新建SpringBoot项目启动报Error错误版本61.0应为52.0","slug":"idea新建SpringBoot项目启动报Error错误版本61.0应为52.0","date":"2024-12-26T07:02:31.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/12/26/idea新建SpringBoot项目启动报Error错误版本61.0应为52.0/","permalink":"https://news-epoch.github.io/2024/12/26/idea%E6%96%B0%E5%BB%BASpringBoot%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%A5Error%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC61.0%E5%BA%94%E4%B8%BA52.0/","excerpt":"","text":"检查Springboot版本和SpringCloud-alibaba 版本和JDK版本的对应关系：SpringCloud-alibaba版本对应 12345678910111213141516&lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;elasticsearch.version&gt;7.10.1&lt;/elasticsearch.version&gt; &lt;spring-boot.version&gt;3.0.2&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2022.0.0.0-RC2&lt;/spring-cloud-alibaba.version&gt; &lt;spring-cloud.version&gt;2022.0.0&lt;/spring-cloud.version&gt; &lt;spring-cloud-starter-alibaba-nacos-config.version&gt;2022.0.0.0-RC2&lt;/spring-cloud-starter-alibaba-nacos-config.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/parent&gt; 检查搭建的pom.xml文件maven.compiler.target和maven.compiler.source标签版本是否一致。 检查idea启动程序是否一致 检查项目结构的每个模块的jdk版本是否一致 检查idea的Java编译器版本是否一致","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[]},{"title":"判等运算符==与equals的区别？","slug":"判等运算符==与equals的区别？","date":"2024-12-03T08:13:45.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/12/03/判等运算符==与equals的区别？/","permalink":"https://news-epoch.github.io/2024/12/03/%E5%88%A4%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6==%E4%B8%8Eequals%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"","text":"Links: &#x3D;&#x3D; 比较的是引用，equals比较的是内容。 如果变量是基础数据类型，&#x3D;&#x3D; 用于比较其对应值是否相等。如果变量指向的是对象，&#x3D;&#x3D; 用于比较两个对象是否指向同一块存储空间。 equals是Object类提供的方法之一，每个Java类都继承自Object类，所以每个对象都具有equals这个方法。Object类中定义的equals方法内部是直接调用 &#x3D;&#x3D; 比较对象的。但通过覆盖的方法可以让 它不是比较引用而是比较数据内容。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"构造方法、成员变量以及静态成员变量三者的初始化顺序？","slug":"构造方法、成员变量以及静态成员变量三者的初始化顺序？","date":"2024-12-03T08:05:13.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/12/03/构造方法、成员变量以及静态成员变量三者的初始化顺序？/","permalink":"https://news-epoch.github.io/2024/12/03/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%89%E8%80%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%EF%BC%9F/","excerpt":"","text":"Links: 先后顺序：静态成员变量、成员变量、构造方法。 详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"JDK与JRE有什么区别？","slug":"JDK与JRE有什么区别？","date":"2024-12-03T08:01:12.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2024/12/03/JDK与JRE有什么区别？/","permalink":"https://news-epoch.github.io/2024/12/03/JDK%E4%B8%8EJRE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"","text":"Links: JDK：Java开发工具包（Java Development Kit），提供了Java的开发环境和运行环境。 JRE：Java运行环境(Java Runtime Environment)，提供了Java运行所需的环境。 JDK包含了JRE。如果只运行Java程序，安装JRE即可。要编写Java程序需安装JDK.","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"流水线协议","slug":"流水线协议","date":"2024-10-14T12:57:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/10/14/流水线协议/","permalink":"https://news-epoch.github.io/2024/10/14/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"什么是流水线协议？ 允许发送方在没有收到确认前连续发送多个分组，从发送方 向 接收方 传送的系列分组可以堪称是填充到一条流水线(管道中)。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"lscpu命令详解","slug":"lscpu命令详解","date":"2024-10-11T07:18:03.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/10/11/lscpu命令详解/","permalink":"https://news-epoch.github.io/2024/10/11/lscpu%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Links: 内容详解 关键词 详解 Architecture 架构 CPU(s) 逻辑cpu个数 Thread(s) per core 每个核心线程数 Core(s) per socket 每个物理CPU的核数 Socket(s) 物理CPU个数 CPU MHz cpu主频 总核数 &#x3D; 物理CPU个数 * 每颗物理CPU的核数总逻辑CPU数 &#x3D; 物理CPU个数 * 每个物理CPU的核数 * 每个核心线程数","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_操作系统_Linux","slug":"计算机-操作系统-Linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux/"}]},{"title":"ThreadPoolExcutor线程池各个参数如何进行配置呢？","slug":"ThreadPoolExcutor线程池各个参数如何进行配置呢？","date":"2024-10-11T06:44:36.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/10/11/ThreadPoolExcutor线程池各个参数如何进行配置呢？/","permalink":"https://news-epoch.github.io/2024/10/11/ThreadPoolExcutor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%E5%91%A2%EF%BC%9F/","excerpt":"","text":"一、前言 目前很多场景多要用上线程池，每次都要根据自身业务情况，以及服务器配置设置各个参数，有时候又记不住就又要百度了，想着每次都百度，不如自己写一次，加深加深印象。 二、ThreadPoolExecutor的重要参数 先看看ThreadPoolExecutor有哪些构造参数。 123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; ...&#125; 1 corePoolSize: 核心线程数(重要)， 核心线程数有啥作用？ 核心线程会一直存活，就算没有任务需要执行。并且当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理。 如何设置呢？ 设置的前提是，我们要清楚的知道CPU密集型和IO密集型的区别。 什么是CPU密集型？ CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读&#x2F;写I&#x2F;O(硬盘&#x2F;内存)，I&#x2F;O在很短的时间就可以完成，而CPU还有许多运算要处理，所以CPU Loading 很高。在多重程序系统中，大部分时间用来做计算、逻辑判断等CPU动作的程序称之CPU bound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部分时间用在三角函数和开根号的计算，便是属于CPU bound的程序。CPU bound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I&#x2F;O设备。 什么是IO密集型？ IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，此时CPU Loading并不高。I&#x2F;O bound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I&#x2F;O操作，而pipeline做得不是很好，没有充分利用处理器能力。 如何判断机器的CPU核心数？以及分析线程池处理的程序是CPU密集型还是IO密集型 1System.out.println(Runtime.getRuntime().availableProcessors()); 1lscpu [[lscpu命令详解-20241011|lscpu命令详解-20241011]] 获取到线程数和分析完程序后，就可以判断线程数了 如果程序是CPU密集型：corePoolSize &#x3D; CPU核数 + 1如果程序是IO密集型：corePoolSize &#x3D; CPU核数 * 2 2 maximumPoolSize：最大线程数maximumPoolSize &gt;&#x3D; corePoolSize，当有新的任务过来时，且任务队列已满时。线程池会创建新线程来处理任务。maximumPoolSize &#x3D; maxPoolSize，当有新的任务过来时，且任务队列已满时，线程池会拒绝处理任务而抛出异常。 3 keepAliveTime：线程空闲时间当线程空闲时间达到keepAliveTime时，线程会退出，直到当前线程数量&#x3D;corePoolSize。如果allowCoreThreadTimeout&#x3D;true，则会直到线程数量&#x3D;0。 4 queueCapacity：任务队列容量（阻塞队列）当核心线程数达到最大时，新任务会放在队列中排队等待执行。 5 allowCoreThreadTimeout：允许核心线程超时12allowCoreThreadTimeout = true //核心线程会超时关闭allowCoreThreadTimeout = false //核心线程不会超时关闭 6 如何设置？tasks ：每秒的任务数，假设为500~1000taskcost：每个任务花费时间，假设为0.1sresponsetime：系统允许容忍的最大响应时间，假设为1s 做个计算corePoolSize &#x3D; 每秒需要多少个线程处理？threadcount &#x3D; tasks&#x2F;(1&#x2F;taskcost) &#x3D; tasks*taskcout &#x3D; (500 ~ 1000)*0.1 &#x3D; 50~100 个线程。 corePoolSize设置应该大于50。 根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可。 queueCapacity &#x3D; (coreSizePool&#x2F;taskcost)*responsetime 计算可得 queueCapacity &#x3D; 80&#x2F;0.1*1 &#x3D; 800。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行。 切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。 maxPoolSize 最大线程数在生产环境上我们往往设置成corePoolSize一样，这样可以减少在处理过程中创建线程的开销。 rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理。 keepAliveTime和allowCoreThreadTimeout采用默认通常能满足。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"},{"name":"计算机_程序语言_编程思想_并发编程","slug":"计算机-程序语言-编程思想-并发编程","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上","slug":"小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上","date":"2024-10-09T12:22:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2024/10/09/小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上/","permalink":"https://news-epoch.github.io/2024/10/09/%E5%B0%8F%E9%99%88%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%94%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%88%B0Github%20Pages%E4%B8%8A/","excerpt":"","text":"什么是Hexo？ hexo是一个简单静态网页生成工具包 开始安装1 安装Gitgit下载地址 一路权限next就可以了，记得勾选xpath。 2 安装nodeJs下载地址：NodeJSHexo 是基于 node.js 编写的，所以需要安装一下 node.js 和里面的 npm 工具。​ 下载稳定版或者最新版都可以 Node.js，安装选项全部默认，一路点击 Next。​ 最后安装好之后，按 Win+R 打开命令提示符，输入 node -v 和 npm -v，如果出现版本号，那么就安装成功了。 3 安装Hexo 先创建一个文件夹 MyBlog，用来存放自己的博客文件，然后 cd 到这个文件夹下（或者在这个文件夹下直接右键 git bash 打开）。 输入 npm install -g hexo-cli 安装 Hexo。可能会有几个报错，无视它就行，安装成功后，输入hexo -v进行验证是否安装成功，至此 hexo 就安装完了。 接下来初始化一下 hexo, 即初始化我们的网站，进入我们主题根目录 Hexo，输入 hexo init 初始化文件夹，就会生成一下几个目录。 接着输入 npm install 安装必备的组件。 输入hexo g 生成静态网页，然后输入 hexo s 打开本地服务器，网页输入：http://localhost:4000 4 使用Volantis主题(本次用的是volantis5.8) 版本 开发阶段 volantis 6.x 开发阶段 volantis 5.x 稳定阶段 volantis 4.x EOL(End of Life) 阶段&#x2F;小白鼠测试版本 下载Volantis主题：https://github.com/volantis-x/hexo-theme-volantis/archive/refs/tags/5.8.0.zip 解压到D:\\code\\blog\\hexo-server\\themes\\volantis下面 5 开始使用hexo官方使用文档：https://hexo.io/zh-cn/docs/volantis使用文档：https://volantis.js.org/v6/theme-settings/ 5.1 配置主配置文件在根目录上面先创建 _config.volantis.yml文件，这个文件中的配置信息优先级高于主题文件夹中的配置文件。 修改**_config.yml**文件的：title(网页头名字)、description(网页介绍)、author(作者)、language(网页语言)、timezone(时区)、url(GitHub Page的页面地址)、theme(使用主题，必须跟主题文件夹一致)、deploy(用来自动化部署的) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site# 网页头名字title: 卫大人的杂乱博客subtitle: &#x27;&#x27;# 网页介绍description: &#x27;客官，打尖已久，何时离店，把账结了？&#x27;keywords:# 作者author: 卫大人# 语言language: zh-cn# 时区timezone: Asia/Shanghai# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://news-epoch.github.iopermalink: :year/:month/:day/:title/# permalink: :title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: &#x27;&#x27;filename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truesyntax_highlighter: highlight.jshighlight: line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: falseprismjs: preprocess: true line_number: true tab_replace: &#x27;&#x27;# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Metadata elements## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/metameta_generator: true# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss## updated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;updated_option: &#x27;mtime&#x27;# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Include / Exclude file(s)## include:/exclude: options only apply to the &#x27;source/&#x27; folderinclude:exclude:ignore:# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/# 所属主题theme: volantis# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: https://xxxxxxxxxxxxxxxxxxxxxxxxxx@github.com/xxxxxx/xxxx.github.io.git branch: main 5.1.1 配置推送功能1234deploy: type: git repository: https://xxxxxxxxxxxxxxxxxxxxxxxxxx@github.com/xxxxxx/xxxx.github.io.git branch: main 安装插件： 12npm config set registry http://registry.npmmirror.comnpm install hexo-deployer-git --save 执行命令：hexo g -d 上传离线文件 5.1.2 开启归档 什么是归档？ 博客的归档指的是按照时间顺序排列和归纳博客文章的列表，以便读者可以方便地查找和浏览博客历史文章。 hexo 是通过 hexo-generator-archive 插件实现的。安装插件： npm install hexo-generator-archive 12345archive_generator: per_page: 10 yearly: true monthly: false daily: false 5.1.3 开启Obsidian双链支持安装插件： npm install hexo-backlink --save官方文档：https://github.com/Cyrusky/hexo-backlink/tree/main 1backlink: true 效果展示： 5.1.4 开启自定义菜单参考文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596############################## 自定义右键 ############################### &gt; start### 自定义右键 新rightmenus: enable: true # 右键菜单项及加载顺序 # 内容示例：plugins.[组名], menus.[组名], hr(分割线，推荐去线留白), music(音乐控制器) order: - plugins.navigation - hr - plugins.inputBox - plugins.seletctText - plugins.elementCheck - plugins.elementImage - menus.link - hr - menus.darkMode - plugins.articlePage - music - menus.prevNext ############################ # - &#123;id: &#x27;&#x27;, name: &#x27;&#x27;, icon: &#x27;&#x27;, link: &#x27;&#x27;, event: &#x27;&#x27;, group: &#x27;&#x27;&#125; # id: 唯一值 # name: 用于菜单名称显示 # icon: 用于菜单图标显示 # link: 跳转链接 # event: 事件，当输入内容不为内置事件时，作 JavaScript 代码执行 # group: 菜单项所处分组名称 # 注： # 1. link/event 二选一，同时出现时仅处理 link # 2. 内置事件列表： copyText, copyLink, copyPaste, copyAll, copyCut, copyImg, printMode, readMode # 3. 内置组列表：navigation, inputBox, seletctText, elementCheck, elementImage, articlePage # 4. plugins 列允许自定义组内项目 # 5. menus 列允许自定义组及其内容 # 6. 除 navigation 外的内置组，在显示时会隐藏含 link 属性的菜单项 ########################### # 基础项设置 options: # 图标前缀 fa-solid, fa-regular, fa-light, fa-thin, fa-duotone, fa-brands iconPrefix: fa-solid # 例外，在 articlePage 组显示时（文章页）时依旧显示含 link 属性的菜单项 articleShowLink: false # 当设定全局音乐播放器时，是否一直显示音乐控制菜单。false：仅当音乐播放时启用 musicAlwaysShow: false # 右键内置组，预置实现 plugins: # 导航组件 # 横向排列，共用一行，仅显示图标 (原则上支持的数量不限) navigation: - &#123;id: &#x27;left&#x27;, name: &#x27;转到上一页&#x27;, icon: &#x27;fa-solid fa-arrow-left&#x27;, event: &#x27;history.back()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;right&#x27;, name: &#x27;转到下一页&#x27;, icon: &#x27;fa-solid fa-arrow-right&#x27;, event: &#x27;history.forward()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;redo&#x27;, name: &#x27;刷新当前页面&#x27;, icon: &#x27;fa-solid fa-redo&#x27;, event: &#x27;window.location.reload()&#x27;, group: &#x27;navigation&#x27;&#125; - &#123;id: &#x27;up&#x27;, name: &#x27;回到顶部&#x27;, icon: &#x27;fa-solid fa-arrow-up&#x27;, event: &#x27;VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)&#x27;, group: &#x27;navigation&#x27;&#125; #- &#123;id: &#x27;home&#x27;, name: &#x27;回到首页&#x27;, icon: &#x27;fa-solid fa-home&#x27;, link: &#x27;/&#x27;, group: &#x27;navigation&#x27;&#125; # 文本输入框相关组件 # 生效于 input/textarea，粘贴、剪切、全选 inputBox: - &#123;id: &#x27;copyPaste&#x27;, name: &#x27;粘贴文本&#x27;, icon: &#x27;fa-solid fa-paste&#x27;, event: &#x27;copyPaste&#x27;, group: &#x27;inputBox&#x27;&#125; - &#123;id: &#x27;copyAll&#x27;, name: &#x27;全选文本&#x27;, icon: &#x27;fa-solid fa-object-ungroup&#x27;, event: &#x27;copyAll&#x27;, group: &#x27;inputBox&#x27;&#125; - &#123;id: &#x27;copyCut&#x27;, name: &#x27;剪切文本&#x27;, icon: &#x27;fa-solid fa-cut&#x27;, event: &#x27;copyCut&#x27;, group: &#x27;inputBox&#x27;&#125; # 文本选中类组件 # 生效于右键选中文本，__text__ 为选中的文本。 seletctText: - &#123;id: &#x27;copyText&#x27;, name: &#x27;复制文本&#x27;, icon: &#x27;fa-solid fa-copy&#x27;, event: &#x27;copyText&#x27;, group: &#x27;seletctText&#x27;&#125; - &#123;id: &#x27;searchWord&#x27;, name: &#x27;站内搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;OpenSearch(__text__)&#x27;, group: &#x27;seletctText&#x27;&#125; - &#123;id: &#x27;bingSearch&#x27;, name: &#x27;必应搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;window.open(`https://cn.bing.com/search?q=$&#123;__text__&#125;`)&#x27;, group: &#x27;seletctText&#x27;&#125; #- &#123;id: &#x27;googleSearch&#x27;, name: &#x27;谷歌搜索&#x27;, icon: &#x27;fa-solid fa-search&#x27;, event: &#x27;window.open(`https://www.google.com/search?q=$&#123;__text__&#125;`)&#x27;, group: &#x27;seletctText&#x27;&#125; # 链接判断组件 # 生效于链接处的右键行为，__link__ 为链接地址 elementCheck: - &#123;id: &#x27;openTab&#x27;, name: &#x27;新标签页打开&#x27;, icon: &#x27;fa-solid fa-external-link-square-alt&#x27;, event: &#x27;window.open(__link__)&#x27;, group: &#x27;elementCheck&#x27;&#125; - &#123;id: &#x27;copyLink&#x27;, name: &#x27;复制链接地址&#x27;, icon: &#x27;fa-solid fa-link&#x27;, event: &#x27;copyLink&#x27;, group: &#x27;elementCheck&#x27;&#125; # 图片判断类组件 # 生效于图片类的右键行为，__link__ 为链接地址 elementImage: - &#123;id: &#x27;copyImg&#x27;, name: &#x27;复制图片&#x27;, icon: &#x27;fa-solid fa-image&#x27;, event: &#x27;copyImg&#x27;, group: &#x27;elementImage&#x27;&#125; - &#123;id: &#x27;googleImg&#x27;, name: &#x27;谷歌识图&#x27;, icon: &#x27;fa-solid fa-images&#x27;, event: &#x27;window.open(`https://www.google.com.hk/searchbyimage?image_url=$&#123;__link__&#125;`)&#x27;, group: &#x27;elementImage&#x27;&#125; # 文章页面组件 # 生效于 post.article 页面 articlePage: - &#123;id: &#x27;printMode&#x27;, name: &#x27;打印页面&#x27;, icon: &#x27;fa-solid fa-print&#x27;, event: &#x27;printMode&#x27;, group: &#x27;articlePage&#x27;&#125; - &#123;id: &#x27;readMode&#x27;, name: &#x27;阅读模式&#x27;, icon: &#x27;fa-solid fa-book-open&#x27;, event: &#x27;readMode&#x27;, group: &#x27;articlePage&#x27;&#125; - &#123;id: &#x27;prev&#x27;, name: &#x27;查看上一篇&#x27;, icon: &#x27;fa-solid fa-angles-left&#x27;, event: &quot;volantis.rightmenu.jump(&#x27;prev&#x27;)&quot;, group: &#x27;prevNext&#x27;&#125; - &#123;id: &#x27;next&#x27;, name: &#x27;查看下一篇&#x27;, icon: &#x27;fa-solid fa-angles-right&#x27;, event: &quot;volantis.rightmenu.jump(&#x27;next&#x27;)&quot;, group: &#x27;prevNext&#x27;&#125; # 右键自定义菜单区域 menus: link: - &#123;id: &#x27;help&#x27;, name: &#x27;前往首页&#x27;, icon: &#x27;fa-solid fa-question&#x27;, link: &#x27;/&#x27;, group: &#x27;link&#x27;&#125; - &#123;id: &#x27;examples&#x27;, name: &#x27;前往分类&#x27;, icon: &#x27;fa-solid fa-rss&#x27;, link: &#x27;categories/&#x27;, group: &#x27;link&#x27;&#125; - &#123;id: &#x27;contributors&#x27;, name: &#x27;前往归档&#x27;, icon: &#x27;fa-solid fa-fan&#x27;, link: &#x27;archives/&#x27;, group: &#x27;link&#x27;&#125;# - hr# - &#123;id: &#x27;source_docs&#x27;, name: &#x27;本站源码&#x27;, icon: &#x27;fa-solid fa-code-branch&#x27;, link: &#x27;https://github.com/volantis-x/volantis-docs/&#x27;, group: &#x27;link&#x27;&#125;# - &#123;id: &#x27;source_theme&#x27;, name: &#x27;主题源码&#x27;, icon: &#x27;fa-solid fa-code-branch&#x27;, link: &#x27;https://github.com/volantis-x/hexo-theme-volantis/&#x27;, group: &#x27;link&#x27;&#125; darkMode: - &#123;id: &#x27;darkMode&#x27;, name: &#x27;暗黑模式&#x27;, icon: &#x27;fa-solid fa-moon&#x27;, event: &#x27;volantis.dark.toggle()&#x27;, group: &#x27;darkMode&#x27;&#125;################################# 自定义右键 ############################### &gt; end 5.2 配置主题配置文件5.2.1 配置导航界面1234567891011121314151617181920212223242526############################### 配置导航界面 ############################### &gt; start# 注意事项：建议规范全站路径 URL 最后带一个 &quot;/&quot; 例如 &quot;about/&quot;navbar: visiable: auto # always, auto # 是否一直显示，还是自动显示 logo: # choose [img] or [icon + title] img: volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-NavBar@3x.png icon: title: menu: - name: 博客 icon: fa-solid fa-rss url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 关于 icon: fa-solid fa-info-circle url: about/ search: Search... # Search bar placeholder############################### 配置导航界面 ############################### &gt; end 展示效果图 还需要生成 这些页面的markdown文件，并且修改。 1234hexo new page &quot;categories&quot;hexo new page &quot;tags&quot;hexo new page &quot;archives&quot;hexo new page &quot;about&quot; 修改 D:\\code\\blog\\hexo-server\\source\\tags\\index.md 1234567891011121314---title: 小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上aliases: tags: - 知识管理categories: - 技术分享type: notedate: 2024-10-09 20:22:00update: 2024-10-14 12:28:03draft: falseshare: trueupdate: 2024-10-14 12:28:05--- 修改 D:\\code\\blog\\hexo-server\\source\\categories\\index.md 1234567891011121314---title: 小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上aliases: tags: - 知识管理categories: - 技术分享type: notedate: 2024-10-09 20:22:00update: 2024-10-14 12:28:03draft: falseshare: trueupdate: 2024-10-14 12:28:05--- 修改 D:\\code\\blog\\hexo-server\\source\\archives\\index.md 1234567891011121314---title: 小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上aliases: tags: - 知识管理categories: - 技术分享type: notedate: 2024-10-09 20:22:00update: 2024-10-14 12:28:03draft: falseshare: trueupdate: 2024-10-14 12:28:05--- 修改 D:\\code\\blog\\hexo-server\\source\\about\\index.md 1234567891011121314---title: 小陈教你如何搭建Hexo博客并且自动化部署到Github Pages上aliases: tags: - 知识管理categories: - 技术分享type: notedate: 2024-10-09 20:22:00update: 2024-10-14 12:28:03draft: falseshare: trueupdate: 2024-10-14 12:28:05--- 5.2.2 配置主页导航界面1234567891011121314151617181920212223############################### 主页导航 ############################### &gt; startcover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) # 界面展示格式 display: home: true archive: true others: false # can be written in front-matter &#x27;cover: true&#x27; background: /imges/background/绘梨衣4k.jpg # 配置背景图# background: /imges/background/龙族 永不熄灭的黄金瞳.png# background: https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 logo: # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/blog/Logo-Cover@3x.png title: &#x27;卫大人的杂乱博客&#x27; # 文字显示 subtitle: &#x27;&#x27; search: &quot;搜一下呢？&quot; # search bar placeholder # 搜索框中显示的文字 features: # 搜索框下面显示的导航列表 - name: 主页 icon: # url: / - name: 分类 icon: # url: categories/############################### 主页导航 ############################### &gt; end 展示效果 5.2.3 配置侧边栏界面参考链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889############################### 侧边栏配置 ############################### &gt; startsidebar: position: right # left right # 主页、分类、归档等独立页面 for_page: [blogger, category, tagcloud, donate] # layout: docs/post 这类文章页面 for_post: [toc] # 侧边栏组件库 widget_library: # --------------------------------------- # blogger info widget blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] avatar: /imges/people/卡通头像1.jpeg shape: rectangle # circle, rectangle url: /about/ title: 卫大人 subtitle: jinrishici: &quot;客官，打尖已久，何时离店，把账结了？&quot; # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fa-solid fa-rss url: /atom.xml - icon: fa-solid fa-envelope url: 1651602236@qq.com - icon: fab fa-github url: https://github.com/news-epoch/ # --------------------------------------- # toc widget (valid only in articles) toc: class: toc display: [desktop, mobile] # [desktop, mobile] sticky: true header: icon: fa-solid fa-list title: 本文目录 list_number: false min_depth: 2 max_depth: 5 # --------------------------------------- # music music: class: music display: [desktop, mobile] # [desktop, mobile] pjaxReload: false # 是否 pjax 重载 默认 true; 设置为 false 时 确保所有页面都含有该小部件 # --------------------------------------- # category widget category: class: category display: [desktop] # [desktop, mobile] pjaxReload: true header: icon: fa-solid fa-folder-open title: 文章分类 url: /blog/categories/ # --------------------------------------- # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-tags title: 热门标签 url: /blog/tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # --------------------------------------- # qrcode widget qrcode: class: qrcode display: [desktop, mobile] # [desktop, mobile] height: 64px # Automatic height if not set images: - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png - volantis-static/media/org.volantis/blog/qrcode/github@volantis.png # https://gcore.jsdelivr.net/gh/volantis-x/cdn-org/blog/qrcode/github@volantis.png # --------------------------------------- # lastupdate widget lastupdate: class: lastupdate display: [desktop, mobile] header: icon: fa-solid fa-clock WISTERIA title: 最近更新############################### 侧边栏配置 ############################### &gt; end 展示效果 5.2.4 配置评论系统创建仓库 开启评论系统 安装在Github 安装 giscus App 点击这里安装完成后 去https://giscus.app/zh-CN进行获取信息 和配置根据配置 进行添加信息 1234567891011121314151617181920212223############################### 评论系统 ############################### &gt; startcomments: service: giscus # giscus # https://giscus.app # https://github.com/laymonage/giscus giscus: # 以下配置按照 yml 格式增删填写即可 repo: github名/仓库名 repo-id: &quot;上面图片获取&quot; category: &quot;上面图片获取&quot; category-id: &quot;上面图片获取&quot; mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot; # 以上配置按照 yml 格式增删填写即可 theme: light: &quot;light&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/light.css dark: &quot;dark&quot; # https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@master/css/giscus/dark.css ############################### 评论系统 ############################### &gt; end 展示效果 5.2.5 开启搜索功能123search: enable: true service: hexo 执行命令npm i -S hexo-generator-json-content 5.2.6 添加mermaid支持参考链接：Volantis 主题个性化修改合集| volantis开发文档注入点 | (二)设置hexo支持mermaid 安装插件：npm install --save hexo-filter-mermaid-diagrams 修改主配置文件_config.yml 123456########################## 注入外部文件 ########################################---------&gt; startimport: body_end: - source/_volantis/bodyEnd.ejs - source/_volantis/footer.ejs ########################## 注入外部文件 ########################################---------&gt; end 修改主题配置文件_config.volantis.yml 1234567########################## 支持mermaid ########################################---------&gt; start mermaid: ## mermaid url https://github.com/knsv/mermaid enable: true # default true version: &quot;8.8.1&quot; # default v7.1.2 options: # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js #startOnload: true // default true########################## 支持mermaid ########################################---------&gt; end 下载链接：mermaidJS 下载到$&#123;HEXO_PROJ_PATH&#125;/themes/volantis/source/js/plugins/mermaid保存下来。 添加$&#123;HEXO_PROJ_PATH&#125;/source/_volantis/footer.ejs 123456789&lt;% if (theme.mermaid.enable) &#123; %&gt; &lt;!-- &lt;script src=&#x27;https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js&#x27;&gt;&lt;/script&gt; 支持CDN模式，但是要慢一点，也可以直接引用mermaid.min.js --&gt; &lt;script src=&#x27;/js/plugins/mermaid/mermaid.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; if (window.mermaid) &#123; mermaid.initialize(&#123;theme: &#x27;forest&#x27;&#125;); &#125; &lt;/script&gt; &lt;% &#125; %&gt; 参考： 5.2.7 开启文章字数计算下载插件：npm i hexo-wordcount修改主题文件夹_config.volantis.yml 12345########################## 开启文章字数计算 ################################# &gt; startplugins: # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount wordcount: enable: true ########################## 开启文章字数计算 ################################# &gt; end 效果展示 5.3 开启自动推送功能在博客文件夹中创建文件：hexo-server\\.github\\workflows\\main.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748name: DoubleAm&#x27;s Blog CI/CD # 脚本 workflow 名称on: push: branches: [main, master] # 当监测 main,master 的 push paths: # 监测所有 source 目录下的文件变动，所有 yml,json 后缀文件的变动。 - &#x27;*.json&#x27; - &#x27;**.yml&#x27; - &#x27;**/source/**&#x27;jobs: blog: # 任务名称 timeout-minutes: 30 # 设置 30 分钟超时 runs-on: ubuntu-latest # 指定最新 ubuntu 系统 steps: - uses: actions/checkout@v2 # 拉取仓库代码 - uses: actions/setup-node@v2 # 设置 node.js 环境 - name: Cache node_modules # 缓存 node_modules，提高编译速度，毕竟每月只有 2000 分钟。 uses: actions/cache@v2 # 亲测 Github 服务器编译速度比我自己电脑都快，如果每次构建按5分钟计算，我们每个月可以免费部署 400 次，Github yyds！！！ env: cache-name: cache-node-modules with: path: ~/.npm key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;- $&#123;&#123; runner.os &#125;&#125;-build- $&#123;&#123; runner.os &#125;&#125;- - name: Init Node.js # 安装源代码所需插件 run: | npm install echo &quot;init node successful&quot; - name: Install Hexo-cli # 安装 Hexo run: | npm install -g hexo-cli --save echo &quot;install hexo successful&quot; - name: Build Blog # 编译创建静态博客文件 run: | hexo clean hexo g echo &quot;build blog successful&quot; - name: Deploy DoubleAm&#x27;s Blog # 设置 git 信息并推送静态博客文件 run: | git config --global user.name &quot;news-epoch&quot; git config --global user.email &quot;admin@news-epoch.com&quot; hexo deploy - run: echo &quot;Deploy Successful!&quot;","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"知识管理","slug":"知识管理","permalink":"https://news-epoch.github.io/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2024-09-25T13:49:01.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2024/09/25/HTTP状态码/","permalink":"https://news-epoch.github.io/2024/09/25/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/","excerpt":"","text":"状态码类别 取值范围 作用 说明 1xx 100-199 信息提示 通告信息，可能还需要进一步交互 2xx 200-299 成功 成功完成客户请求的操作，并进行响应 3xx 300-399 重定向 表示资源已经移走，需要向新URL发请求 4xx 400-499 客户端错误 由于客户端请求错误，无法成功响应 5xx 500-599 服务器错误 由于服务器端错误，无法成功响应","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"Muddy_Puddles","slug":"Muddy_Puddles","date":"2023-12-19T06:41:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/12/19/Muddy_Puddles/","permalink":"https://news-epoch.github.io/2023/12/19/Muddy_Puddles/","excerpt":"","text":"Links: Muddy_Puddles 一、人物 Peppa George Daddy 一、对话 [!timeline] Muddy Puddles(it is raining todaySo,Peppa and George Cannot play outside)&gt;PeppaDaddy，it’s stopped raining.Can we go out to play? Daddy Alright, run along you two. Peppa Peppa loves jumping in muddy puddles Mummy Peppa. If you jump in muddy puddlesyou must wear your boots. Peppa Sorry, Mummy George George likes to jump in muddy puddles, too. Peppa George. If you jump in muddy puddlesyou must wear your boots. George Peppa likes to look after her little brothe,George. Peppa George,let’s find some more puddles. official Peppa and George are having a lot of fun.Peppa has found a little puddleGeorge has found a big puddle Peppa Look, George.There’s a really big puddle. official George wants to jump into the big puddle first. Peppa Stop.George.I must check if it’s safe for you.Good. it is safe for you.Sorry,George.it’s only mud. official Peppa and George love jumping in muddy puddles. Peppa Come on, George.Let’s go and show Daddy. Daddy Goodness me. Pappe Daddy. Daddy.Guess what we’ve been doing. Daddy Let me think…Have you been watching television? Peppa No. No. Daddy. Daddy Have you just had a bath? Peppa No. No Daddy I know. You’ve been jumping in muddy puddles. Peppa Yes. Yes. Daddy. We’ve been jumping in muddy puddles. Daddy Ho. Ho. And look at the mess you’re in. Peppa oooh… Daddy Oh. well, it’s only mud.Let’s clean up quickly before Mummy sees the mess. Peppa Daddy, when we’ve cleaned upwill you and Mummy Come and play,too？ Daddy Yes, we can all play in the garden. official Peppa and George are wearing their boots.Mummy and Daddy are wearing their boots.Peppa loves jumping up and down in mudy puddles.Everyone loves juping up and down in muddy puddles. Mummy Oh, Daddy pig, look at the mess you’re in. Peppa it’s only mud. Peppa I’m Peppa Pig.This is my little brother, George. 三、单词 单词 释义 play outside 出去玩 Alright—&gt; all right 没问题 along 一起 jumping in 跳进 muddy 泥泞 puddles 划桨留下的水漩涡 hava a lot of fun 玩得很高心，有许多乐趣 a lot of fun 非常有意思 It’s only mud 惯用语，mud 弄脏 Goodness me 天哪 guess what 猜猜看 buth 沐浴 Ho 表示惊讶 mess 混乱 clean up 收拾干净 in the garden 在花园里。 watch television 看电视","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"基础学科_英语","slug":"基础学科-英语","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91-%E8%8B%B1%E8%AF%AD/"}]},{"title":"【小猪佩奇学英语】基础词汇量2000，精学版-20231219","slug":"【小猪佩奇学英语】基础词汇量2000，精学版-20231219","date":"2023-12-19T06:39:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/12/19/【小猪佩奇学英语】基础词汇量2000，精学版-20231219/","permalink":"https://news-epoch.github.io/2023/12/19/%E3%80%90%E5%B0%8F%E7%8C%AA%E4%BD%A9%E5%A5%87%E5%AD%A6%E8%8B%B1%E8%AF%AD%E3%80%91%E5%9F%BA%E7%A1%80%E8%AF%8D%E6%B1%87%E9%87%8F2000%EF%BC%8C%E7%B2%BE%E5%AD%A6%E7%89%88-20231219/","excerpt":"","text":"Links: 第一天Muddy_Puddles","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"基础学科_英语","slug":"基础学科-英语","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91-%E8%8B%B1%E8%AF%AD/"}]},{"title":"教你如何使用Nacos注册中心-20231216","slug":"教你如何使用Nacos注册中心-20231216","date":"2023-12-16T14:47:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/12/16/教你如何使用Nacos注册中心-20231216/","permalink":"https://news-epoch.github.io/2023/12/16/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-20231216/","excerpt":"","text":"Links:Nacos官网| Nacos版本对应说明 一、简介 Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 二、应用1 安装123456789101112docker run -d --name nacos \\-p 8848:8848 \\-p 9848:9848 \\-p 9849:9849 \\--privileged=true \\-e JVM_XMS=256m \\-e JVM_XMX=256m \\-e MODE=standalone \\-v /Data/SoftData/DockerData/nacos/logs/:/home/nacos/logs \\-v /Data/SoftData/DockerData/nacos/conf/:/home/nacos/conf/ \\--restart=always \\nacos/nacos-server:v2.1.0","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java","slug":"计算机-程序语言-Java","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java/"}]},{"title":"类的加载器&反射&模块化-20230726","slug":"类的加载器&反射&模块化-20230726","date":"2023-07-26T07:47:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/07/26/类的加载器&反射&模块化-20230726/","permalink":"https://news-epoch.github.io/2023/07/26/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8&%E5%8F%8D%E5%B0%84&%E6%A8%A1%E5%9D%97%E5%8C%96-20230726/","excerpt":"","text":"Links: 一、类的加载器 JAVA虚拟机是如何读取写的java代码呢？ JVM虚拟机先将java代码转换成二进制的字节码文件，即class文件，然后将通过类的加载器将class文件读取到内存中，然后这个时候就要进行类的连接，即：对这个二进制数据进行合法性检查–通过–&gt;内存分配—-&gt;然后将二进制数据中的符号应用替换为直接应用。最后进行类的初始化 用通俗的话来说，类似与机场登机，先进行扫描是否携带不合规的物品，然后为你分配对应的登机口进行登机，登机后，空姐人员会通过你手上的座位号带你前往对应的座位。 二、反射 什么是反射呢？ 通过class类通过对应的class字节码文件获取到对应的对象，并且调用对应的方法实现创建、加载成员对象、成员方法等相关操作，可以让类在程序运行过程当中进行该操作。 1 主要方法 获取到class类的对象1234567// 通过反射获取java类的三种方法第一种Class&lt;?&gt; c1 = Student.class;第二种Class&lt;?&gt; c1 = (new Student()).getClass();第三种Class&lt;?&gt; c1 = Class.forName(&quot;com.cwg.dao.Student&quot;); 反射获取类的构造方法并使用123456练习1:通过反射实现如下操作Students = new Student(&quot;林青霞”30,&quot;西安);System.out.println(s);练习2:通过反射实现如下操作Students = new Student(&quot;林青霞”);System.out.println(s): 反射获取类的成员变量 1234567练习:通过反射实现如下操作Student s = new Student0s.name=“林青霞”s.age = 30;s.address =“西安”System.out.println(s); 反射获取类的成员方法12345678910练习1:通过反射实现如下操作Student s = new Student();s.method1();s.method2(&quot;林青霞”);String ss = s.method3(&quot;林青霞&quot;,30);System.out.println(ss);s.function();练习2:我有一个ArrayList&lt;lnteger&gt;集合，现在我想在这个集合中添加一个字符串数据，如何实现?练习3:通过配置文件运行类中的方法 三、模块 什么是模块化呢？ 由于在以前版本时，无论系统是运行一个小的程序，还是一个大的程序，都要加载一个完整的JRE环境，这让整个程序十分臃肿。这时Java 9 正式推出了模块化系统，它把java拆分成N个模块，并允许java程序可以根据需要选择性的加载程序必须的java模块，这样就可以以轻量化的方式运行","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"}]},{"title":"搭建内网穿透-202307031548","slug":"搭建内网穿透-202307031548","date":"2023-07-03T07:48:00.000Z","updated":"2023-07-03T07:48:11.000Z","comments":true,"path":"2023/07/03/搭建内网穿透-202307031548/","permalink":"https://news-epoch.github.io/2023/07/03/%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F-202307031548/","excerpt":"","text":"Links: Wireguard客户端下载 背景现在个需求，需要从公司电脑连接到家里的服务器,所以，就使用了一个开销比较小的方式，内网穿透 基于Wireguard技术的虚拟个人网络搭建（基于Lighthouse服务器） Linux 安装 是基于内核5.6以上，如果低于5.6内核，需要升级到5.6+加载modprobe wireguard和lsmod|grep Wireguard 查看是否携带 1 手动安装Wireguard1.1 安装Wireguard（以ubuntu20.04为基础）123456789#root权限sudo -i#安装wireguard软件apt install wireguard resolvconf -y#开启IP转发echo &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt; /etc/sysctl.confsysctl -p 1.2 进入配置存储路径，调整目录权限12345cd /etc/wireguard/chmod 0777 /etc/wireguard#调整目录默认权限umask 077 1.3 生成服务器秘钥12345#生成私钥wg genkey &gt; server.key#通过私钥生成公钥wg pubkey &lt; server.key &gt; server.key.pub 1.4 生成客户端(client1)秘钥12345#生成私钥wg genkey &gt; client1.key#通过私钥生成公钥wg pubkey &lt; client1.key &gt; client1.key.pub 1.5 显示所有生成的秘钥1cat server.key &amp;&amp; cat server.key.pub &amp;&amp; cat client1.key &amp;&amp; cat client1.key.pub 1.6 自动创建服务器配置文件123456789101112131415echo &quot;[Interface]PrivateKey = $(cat server.key) # 填写本机的privatekey 内容Address = 10.0.8.1 #本机虚拟局域网IPPostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADEPostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE#注意eth0需要为本机网卡名称ListenPort = 50814 # 监听端口DNS = 8.8.8.8MTU = 1420[Peer]PublicKey = $(cat client1.key.pub) #自动client1的公钥AllowedIPs = 10.0.8.10/32 #客户端所使用的IP&quot; &gt; wg0.conf 1.7 设置服务器开机自启动1systemctl enable wg-quick@wg0 1.8 启动wireguard1234#启动wg0wg-quick up wg0#关闭wg0wg-quick down wg0 1.9 手动创建服务器配置文件（待完成）1nano /etc/wireguard/wg0.conf 2 Docker安装Wireguard2.1 通过容器安装wg-easy 升级服务器内核为5.6以上，参考文档：Centos7 升级内核-202307031229 启动wireguard、iptables模块：modprobe iptable_nat和modprobe wireguard 运行docker。1234567891011121314151617docker run -d \\ --name=wg-easy \\ -e WG_HOST=123.123.123.123 (🚨这里输入服务器的公网IP) \\ -e PASSWORD=passwd123 (🚨这里输入你的密码) \\ -e WG_DEFAULT_ADDRESS=10.0.8.x （🚨默认IP地址）\\ -e WG_DEFAULT_DNS=114.114.114.114 （🚨默认DNS）\\ -e WG_ALLOWED_IPS=10.0.8.0/24 （🚨允许连接的IP段）\\ -e WG_PERSISTENT_KEEPALIVE=25 （🚨重连间隔）\\ -v ~/.wg-easy:/etc/wireguard \\ -p 51820:51820/udp \\ -p 51821:51821/tcp \\ --cap-add=NET_ADMIN \\ --cap-add=SYS_MODULE \\ --sysctl=&quot;net.ipv4.conf.all.src_valid_mark=1&quot; \\ --sysctl=&quot;net.ipv4.ip_forward=1&quot; \\ --restart unless-stopped \\ weejewel/wg-easy 2.2 更新容器命令123docker stop wg-easydocker rm wg-easydocker pull weejewel/wg-easy 3 安装客户端3.1 wireguard客户端下载地址1https://www.wireguard.com/install/ 3.2 windows 客户端配置（以client1为例）123456789[Interface]PrivateKey = 6M8HEZioew+vR3i53sPc64Vg40YsuMzh4vI1Lkc88Xo= #此处为client1的私钥Address = 10.0.8.10 #此处为peer规定的客户端IPMTU = 1500[Peer]PublicKey = Tt5WEa0Vycf4F+TTjR2TAHDfa2onhh+tY8YOIT3cKjI= #此处为server的公钥AllowedIPs = 10.0.8.0/24 #此处为允许的服务器IPEndpoint = 114.132.56.178:50814 #服务器对端IP+端口 3.3 Linux 客户端节点client2 安装 wireguard，内核5.6+ 自带wireguard1234567891011121314151617181920212223242526272829# 客户端## 生成私钥wg genkey &gt; client2.key## 通过私钥生成公钥wg pubkey &lt; client2.key &gt; client2.key.pub## 将配置文件写入wg0.conf[Interface]PrivateKey = cat client2.key // Address = 10.0.9.20/24DNS = 114.114.114.114[Peer]PublicKey = cat server.key.pubPresharedKey = server服务器通过web端自动生成的AllowedIPs = 10.0.9.0/24PersistentKeepalive = 25Endpoint = server服务器IP:对外暴露的端口# 服务端通过web端创建连接添加[Peer]PublicKey = cat client.key.pubPresharedKey = server服务器通过web端自动生成的AllowedIPs = 客户端IP/32# 启动服务端wg-quick up wg0 4 问题4.1 报错一1234出现报错：/usr/bin/wg-quick: line 32: resolvconf: command not found执行：apt install openresolv","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_操作系统_linux","slug":"计算机-操作系统-linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-linux/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://news-epoch.github.io/tags/WireGuard/"}]},{"title":"Centos7 升级内核-202307031229","slug":"Centos7 升级内核-202307031229","date":"2023-07-03T04:29:00.000Z","updated":"2023-07-03T04:29:16.000Z","comments":true,"path":"2023/07/03/Centos7 升级内核-202307031229/","permalink":"https://news-epoch.github.io/2023/07/03/Centos7%20%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8-202307031229/","excerpt":"","text":"Links: 背景 因为搭建VPN——Wireguard的容器启动对centos 的内核有要求，所以需要更高版本的内核才能支持，所以以下将介绍yum和rpm两种升级内核方式。 关于内核种类: kernel-ml——kernel-ml 中的ml是英文【 mainline stable 】的缩写，elrepo-kernel中罗列出来的是最新的稳定主线版本。 kernel-lt——kernel-lt 中的lt是英文【 long term support 】的缩写，elrepo-kernel中罗列出来的长期支持版本。ML 与 LT 两种内核类型版本可以共存，但每种类型内核只能存在一个版本。 在线 yum 安装1）查看当前内核版本信息 12345678uname -a# 仅查看版本信息uname -r# 通过绝对路径查看查看版本信息及相关内容cat /proc/version# 通过绝对路径查看查看版本信息cat /etc/redhat-release 2）导入仓库源 123456789# 1、更新yum源仓库yum -y update# 2、导入ELRepo仓库的公共密钥rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org# 3、安装ELRepo仓库的yum源yum install https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm# 4、查询可用内核版本yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available 3）选择 ML 或 LT 版本安装 123456789# 安装 最新版ML 版本# yum --enablerepo=elrepo-kernel install kernel-ml-devel kernel-ml -y# 安装 最新版LT 版本# yum --enablerepo=elrepo-kernel install kernel-lt-devel kernel-lt -y# 不带版本号就安装最新版本，这里我们安装 LT 5.4.225-1.el7.elrepo版本# 安装 LT 版本，K8S全部选这个yum --enablerepo=elrepo-kernel install kernel-lt-devel-5.4.225-1.el7.elrepo.x86_64 kernel-lt-5.4.225-1.el7.elrepo.x86_64 -y 安装完成后需要设置 grub2，即内核默认启动项4） 设置启动 内核安装好后，需要设置为默认启动选项并重启后才会生效。 查看系统上的所有可用内核 12345awk -F\\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg0 : CentOS Linux (5.4.249-1.el7.elrepo.x86_64) 7 (Core)1 : CentOS Linux (3.10.0-1160.11.1.el7.x86_64) 7 (Core)2 : CentOS Linux (3.10.0-1160.el7.x86_64) 7 (Core)3 : CentOS Linux (0-rescue-20201228113502924739250506992733) 7 (Core) 刚刚安装的内核即0 : CentOS Linux (5.4.225-1.el7.elrepo.x86_64) 7 (Core)[[Linux更换内核，grub.cfg没有对应版本内核的menuentry选项的解决办法-20250523|Linux更换内核，grub.cfg没有对应版本内核的menuentry选项的解决办法-20250523]] 我们需要把grub2默认设置为0可以通过 grub2-set-default 0 命令或编辑 /etc/default/grub 文件来设置 grub2-set-default 0 将GRUB_DEFAULT设置为0，如下1234567891011vim /etc/default/grub GRUB_TIMEOUT=1GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;GRUB_DEFAULT=saved //修改为0GRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL_OUTPUT=&quot;console&quot;GRUB_CMDLINE_LINUX=&quot;crashkernel=auto spectre_v2=retpoline net.ifnames=0 console=tty0 console=ttyS0,115200n8 noibrs&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;grub2-mkconfig -o /boot/grub2/grub.cfgreboot -h now","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_操作系统_Linux","slug":"计算机-操作系统-Linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux/"},{"name":"计算机_操作系统_linux","slug":"计算机-操作系统-linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-linux/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://news-epoch.github.io/tags/WireGuard/"}]},{"title":"ICMP","slug":"ICMP","date":"2023-04-18T15:56:01.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/04/18/ICMP/","permalink":"https://news-epoch.github.io/2023/04/18/ICMP/","excerpt":"","text":"在主机或路由器之间实现差错信息控制、信息探测，例如ping的实现","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"DHCP","slug":"DHCP","date":"2023-04-18T15:03:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/04/18/DHCP/","permalink":"https://news-epoch.github.io/2023/04/18/DHCP/","excerpt":"","text":"用来动态给主机自动分配IP地址，DHCP服务器端口号67 客户端端口号68","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"ARQ","slug":"ARQ","date":"2023-04-04T15:54:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/04/04/ARQ/","permalink":"https://news-epoch.github.io/2023/04/04/ARQ/","excerpt":"","text":"是OSI模型中针对传输层和数据链路层的错误纠正协议之一，用来解决数据丢失、比特差错、乱序。同时也是TCP实现可靠传输的重要协议。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"},{"name":"zk-todo","slug":"zk-todo","permalink":"https://news-epoch.github.io/tags/zk-todo/"},{"name":"booknote","slug":"booknote","permalink":"https://news-epoch.github.io/tags/booknote/"},{"name":"计算机","slug":"计算机","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"基础学科","slug":"基础学科","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"}]},{"title":"TCP","slug":"TCP","date":"2023-03-30T16:52:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/30/TCP/","permalink":"https://news-epoch.github.io/2023/03/30/TCP/","excerpt":"","text":"Internet提供面向连接服务的传输协议额","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"UDP","slug":"UDP","date":"2023-03-30T16:49:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/03/30/UDP/","permalink":"https://news-epoch.github.io/2023/03/30/UDP/","excerpt":"","text":"Internet提供无连接服务的传输层协议。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"MTU","slug":"MTU","date":"2023-03-28T16:54:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/28/MTU/","permalink":"https://news-epoch.github.io/2023/03/28/MTU/","excerpt":"","text":"是硬件(物理层)的一个特性。MTU的大小以字节（octets ）为基本单位。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"MIME","slug":"MIME","date":"2023-03-28T16:40:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/28/MIME/","permalink":"https://news-epoch.github.io/2023/03/28/MIME/","excerpt":"","text":"邮件传输非7位ASCII码文本内容时，必须依据一个标准将非7位ASCII码文本内容转换为7位ASCII码文本内容，然后在传输，而提供转换功能。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"SMTP","slug":"SMTP","date":"2023-03-28T16:25:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/28/SMTP/","permalink":"https://news-epoch.github.io/2023/03/28/SMTP/","excerpt":"","text":"Internet电子邮件中核心应用层协议。实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输 SMTP通过3个阶段的应用层交互完成邮件的传输： 握手阶段 邮件传输阶段 关闭阶段 SMTP的特点： SMTP定义了14条命令,每条命令由4个字母实现 SMTP定义了21种应答信息，一般只有一行，由3位数字的代码标识 SMTP只能传输7位ASCII码文本内容 SMTP传送的邮件内容不能包含”CRLF.CRLF”,因为该信息用于标识邮件内容的结束 SMTP是“推动”协议。（补充：HTTP是“拉动”协议） SMTP使用TCP连接是持久的。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"RTT","slug":"RTT","date":"2023-03-28T15:07:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/28/RTT/","permalink":"https://news-epoch.github.io/2023/03/28/RTT/","excerpt":"","text":"HTTP客户进程向服务器请求建立连接，从客户发送连接请求，到收到服务器连接确认，用时一个往返时间。RTT作为一个时间单位来使用","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"},{"name":"zk-todo","slug":"zk-todo","permalink":"https://news-epoch.github.io/tags/zk-todo/"},{"name":"booknote","slug":"booknote","permalink":"https://news-epoch.github.io/tags/booknote/"},{"name":"计算机","slug":"计算机","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"基础学科","slug":"基础学科","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"}]},{"title":"统一资源定位符","slug":"统一资源定位符","date":"2023-03-27T15:27:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/03/27/统一资源定位符/","permalink":"https://news-epoch.github.io/2023/03/27/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6/","excerpt":"","text":"URL地址主要两个部分组成：存放对象的主机域名(或IP地址)和对象的路径名称","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"服务访问点","slug":"服务访问点","date":"2023-03-27T14:30:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/03/27/服务访问点/","permalink":"https://news-epoch.github.io/2023/03/27/%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%82%B9/","excerpt":"","text":"相邻层间的服务是通过其接口面上的服务访问点进行的，每个SAP都有一个唯一的地址号码","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"带宽","slug":"带宽","date":"2023-03-02T15:23:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2023/03/02/带宽/","permalink":"https://news-epoch.github.io/2023/03/02/%E5%B8%A6%E5%AE%BD/","excerpt":"","text":"在通信和信号处理领域中，指的是信号的频带宽度(最高和最低频率之差)，单位：HZ(赫兹)。在计算机网络中，指的是一条链路或信道的最高数据速率，单位：bit&#x2F;s(位每秒)通俗来说，就是最高速率。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"MarkDown教程","slug":"MarkDown教程","date":"2023-03-02T14:01:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2023/03/02/MarkDown教程/","permalink":"https://news-epoch.github.io/2023/03/02/MarkDown%E6%95%99%E7%A8%8B/","excerpt":"","text":"1 绘图Mermaid流程1.1 绘图方向 命令 方向 TB(TD) 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 1.2 节点形状 命令 形状 A[text] 文本框（默认形状） B(text) 圆角框 C([text]) 体育场型框 D[(text)] 数据库型框 E((text)) 圆形框 F&gt;text] 非对称框 G{text} 菱形框 H 六边形框 I[&#x2F;text&#x2F;] J[\\text\\] 平行四边形框 1.3 连线形状 命令 形状 添加文本 A1 –&gt; B1 直线箭头 –text–&gt; A2 — B2 直线 –text— A3 -.-&gt; B3 虚线箭头 -.text.-&gt; A4 -.- B4 虚线 -.text.– A5 &#x3D;&#x3D;&#x3D; B5 加粗直线 =&#x3D;text&#x3D;&#x3D;&#x3D; A6 &#x3D;&#x3D;&gt; B6 加粗直线箭头 =&#x3D;text&#x3D;&#x3D;&gt; 123graph TBA --&gt; D &amp; E &amp; FB &amp; C -.-&gt; F 123graph TBA --&gt; D &amp; E &amp; FB &amp; C -.-&gt; F 1.4 子流程图代码格式如下： 123subgraph xxx ······end graph TB subgraph one A1 --> B1 end subgraph two A2 === B2 end subgraph three A3 -.-> B2 end 1.5 注释graph流程图中以 %% 为开头注释一行。 1.6 链接graph流程图可以在节点标识上绑定 URL ，当点击对应节点时，链接到对应的 URL。语法格式如下 1click nodeID URL 举例： graph LR; A-->B; click A \"https://www.baidu.com\" 1.7 时序图使用mermaid绘制时序图 - 掘金 (juejin.cn) sequenceDiagram Type Description -&gt; 实线 –&gt; 虚线 -&gt;&gt; 带箭头实线 –&gt;&gt; 带箭头虚线 -x 断头实线 –x 断头虚线 -) 表示异步的箭头实线 (async) –) 表示异步的箭头虚线 (async) 1.7.1 笔记我们可以在时序图上面添加一些笔记或者说明，语法如下： 12Note [ right of | left of | over ] [Actor]复制代码 sequenceDiagram 客户端-->>服务器: 发送账号密码 Note over 服务器: 超时时间3s 服务器-->>服务器: 校验账号密码","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"效率_工具","slug":"效率-工具","permalink":"https://news-epoch.github.io/tags/%E6%95%88%E7%8E%87-%E5%B7%A5%E5%85%B7/"}]},{"title":"计算机网络原理-202302070026","slug":"计算机网络原理-202302070026","date":"2023-02-06T16:26:00.000Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"2023/02/06/计算机网络原理-202302070026/","permalink":"https://news-epoch.github.io/2023/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-202302070026/","excerpt":"","text":"Links: 一、计算机网络概述 计算机网络是互连的，自治的计算机的集合，它是计算机技术和通信技术相互融合的产物。 1 计算机网络基本概念1.1 网络协议 网络通信实体之间在数据交换过程中所遵循的规则或者约定，而遵循的约定或者规则叫做网络协议。 网络协议由三部分组成： 语法：实体之间，交换信息要遵循的格式与结构或者电平等。 语义：实体之间，交换信息中的需要携带的控制信息和这些控制信息的含义。 时序：实体之间，交换信息的顺序以及如何匹配或适应彼此的速度 1.2 计算机网络的功能 硬件资源共享：laaS平台 软件资源共享：SaaS平台 信息资源共享：公共信息数据共享 1.3 计算机网络的分类 按覆盖范围分类 个域网(PAN)：1-10m。个人使用的网络,例如随身携带的设备通过无线技术构成的小范围网络 局域网(LAN)：10m-1km。家庭、小企业覆盖的网络 城域网(MAN)：5-50km。整个城市或者的计算机网络 广域网(WAN)：几十到几百千米。跨城市等覆盖的网络 按拓扑结构分类 网状型：广域网&#x2F;核心网。可靠性高，多条链路故障，网络依旧使用。结构复杂，成本高，选路复杂 树型：局域网。易于扩展，故障易隔离。根节点要求高。 星型：个域网&#x2F;局域网，点对点，易于监控、故障诊断、隔离。中央节点故障，全网瘫痪。 总线型：局域网，广播，结构简单，电缆数量少，易于扩展。范围受限，容易产生冲突。 环形：局域网&#x2F;城域网，电缆长度短，使用光纤，避免冲突。节点故障全网瘫痪。 混合型：大多数实际网络。易于扩展，构建不同规模的网络。结构复杂，管理与维护复杂。 按交换方式分类 电路交换 报文交换 分组交换 按网络用户属性分类 公有网：面向公众开放的网络 私有网：某个组织(政府)出资建设专门面向该组织，不向公众开放。 2 计算机网络的结构2.1 网络边缘 连接到网络上的计算机、手机、服务器、智能家电等成为主机或者端系统，连接到网上的所有端系统构成了网络边缘 2.2 网络边缘如何连接到网络当中呢？ 这就引出了接入网络的概念，那么什么是接入网络呢？ 接入网络是指：实现网络边缘的端系统与网络核心连接的网络。 接入网络可以分类成五种： 电话拨号接入。[[# 2.2.1 电话拨号接入| &gt; 2.2.1 电话拨号接入]] 非对称数字用户线路ADSL。[[#2.2.2 非对称数字用户线路ADSL| &gt; 2.2.2 非对称数字用户线路ADSL]] 混合光纤同轴电缆HFC。 局域网(wifi、以太网) 移动接入网络 2.2.1 电话拨号接入 很久之前通过电话拨号进行上网，通过调制解调器进行数字信号和模拟信号的转换。56kbit&#x2F;s 2.2.2 非对称数字用户线路ADSL 利用电话网络接入 基于频分多路复用 非对称：下载速度和上传速度不一致 独享式接入： 2.2.3 混合光纤同轴电缆HFC接入网络 利用有线电视网络接入技术 基于频分多路复用技术 非对称 共享接入(多个用户共享上、下行带宽) 2.2.4 局域网技术，以太网、WIFI技术2.2.5 移动接入网络 利用移动网络通信，如3G&#x2F;4G&#x2F;5G 2.3 网络核心 网络核心是由通信链路互联的分组交换设备(路由器、交换机)构成的网络，作用是实现网络边缘中主机之间的中继与转发 。 3 数据交换技术 交换设备具有多个通信端口，可以同时连接多个通信结点数据交换是实现大规模网络核心上进行数据传输的技术基础 3.1 电路交换 电路交换是最早出现的一种交换方式，电话网络是最早、最大的电路交换网络。 graph LR subgraph 电路交换步骤 A[建立电路] B[传输数据] C[拆除电路] A-->B-->C end 电路交换的优点：实时性高，时延短电路交换的缺点：不适用于猝发式通信，信道利用率低(建立链路后，只能两个终端使用)。 3.2 报文交换 什么是报文？ 发送方把要发送的信息附加上发送&#x2F;接收主机的地址和控制信息 交换结点的这种接收-暂存-转发的工作方式，称为存储-转发的交换方式。 graph LR subgraph 报文结构 A[首部]-->B[数据] end 报文交换的优点：信道利用率高报文交换的缺点：网络的延迟时间变长，有时还需要丢弃报文。 3.3 分组交换 分组交换也称为包交换，它是将数据分成一个个的小的数据块，每个数据块携带目的地址和序号等附加信息进行传输，并且采用的是存储—转发交换方式，是计算机网络中使用最广泛的交换技术 graph LR subgraph 分组结构 A[首部]-->B[分组] end 分组交换的优点：交换设备的存储容量要求低、交换速度快、可靠传输效率高、更加公平分组交换的缺点：有效传输效率降低 注：在其他条件相同的情况下，分组长度越长，延迟时间越长 4 计算机网络性能 单位时间内，源主机向宿主机发送的最大比特数，用来描述网络传输数据的快慢。单位：bit&#x2F;s 1Kbit&#x2F;s&#x3D;1000bit&#x2F;s&#x3D;10^3bit&#x2F;s1Mbit&#x2F;s&#x3D;1000000bit&#x2F;s&#x3D;10^6bit&#x2F;s1Gbit&#x2F;s&#x3D;1000000000bit&#x2F;s&#x3D;10^9bit&#x2F;s1Tbit&#x2F;s&#x3D;1000000000000bit&#x2F;s&#x3D;10^12bit&#x2F;s 300-名词库/速率.md速率 在通信和信号处理领域中，指的是信号的频带宽度(最高和最低频率之差)，单位：HZ(赫兹)。在计算机网络中，指的是一条链路或信道的最高数据速率，单位：bit&#x2F;s(位每秒)通俗来说，就是最高速率。 300-名词库/带宽.md带宽 可以有结点时延、排队时延、传播时延、传输时延。表示从一个网络结点(网络设备)到另一个网络结点(网络设备)所需要的时间 结点处理时延dc：单位时间内，交换设备检查分组是否有差错，确定如何转发分组的时间。 排队时延dq：单位时间内，交换设备中数据包从排队开始到输出链路发送到下一个结点的排队时间。 传输时延dt：单位时间内，信号在实际链路中传播时间(第一位从链路开始到最后一位完全进入链路的发送时间)—&gt;分组长度L&#x2F;信号传播**最大速率(带宽)**R 传播时延dp：信号从发送端出来，经过一段物理链路到达接受端所需要的时间。dp&#x3D;D(物理链路长度)&#x2F;V(传播速度) 300-名词库/时延.md时延 是指一段物理链路的传播时延与带宽的乘积,即是距离，可以用来表示在单条链路上可以存放的数据位数， 300-名词库/时延带宽积.md时延带宽积 从源网络设备发出N个数据包，在宿网络设备接收到N-n个数据包，其中在传输过程中丢失的数据包占总数据包的百分比 .反映了链路的阻塞程度。 NS：为发送分组总数Nr：接收分组总数Nl：丢失分组总数 300-名词库/丢包率.md丢包率 单位时间内，从源主机到宿主机的实际到达量。注意：吞吐量会受到网络链路带宽、网络复杂性、网络协议、网络拥塞程度影响。在分组交换网络中，吞吐量约等于瓶颈链路的带宽，即，三段链路中的最小带宽。 300-名词库/吞吐量.md吞吐量 5 计算机网络体系结构 计算机网络所划分的层次以及各层协议的集合就称为计算机网络体系结构 5.1 OSI参考模型开放系统网络(Open System Internet) graph LR A[应用层] B[表示层] C[会话层] D[传输层] E[网络层] F[数据链路层] G[物理层] A--报文-->B-->C-->D--数据段-->E--分组/包-->F--帧-->G OSI层 作用 协议 协议数据单元 应用层 为用户提供一个使用网络应用的接口 HTTP&#x2F;FTP&#x2F;SMTP&#x2F;TELNET 报文 表示层 用于处理应用实体间交换数据的语法，解决格式和数据表示的差别，不独立存在 会话层 通过两台计算机间建立、管理、终止通信来完成会话。不独立存在 SSL&#x2F;TLS 传输层 实现端到端的可靠数据传输 TCP&#x2F;UDP 报文段&#x2F;数据段 网络层 转发和路由 OSPF&#x2F;BGP&#x2F;VRRP 分组&#x2F;包 数据链路层 差错控制、流量控制、链路管理、寻址 帧 物理层 传输介质上实现无结构比特流传输 比特流 数据单元：层与层的实体之间传送的比特组称为数据单元。 这个实体是什么呢？ 指在特定层次上执行特定功能的协议实体，例如：HTTP、FTP、TCP、UDP都是不同的协议实体。 应用层实体：处理应用数据（如网页内容），并将其封装成应用层消息。 传输层实体：将应用层消息封装成段（TCP）或数据报（UDP），并添加相应的头部信息。 网络层实体：将传输层段或数据报封装成包，并添加路由信息。 数据链路层实体：将网络层包封装成帧，添加物理地址信息。 协议数据单元：每一层实体，将数据单元处理封装后的数据单元称为协议数据单元。 5.2 TCP&#x2F;IP参考模型 TCP&#x2F;IP层 数据格式 典型协议 应用层 报文 传输层 段 TCP,UDP 网络互连层 数据报 IP,ICMP 网络接口层 帧 5.3 五层参考模型 描述计算机网络中最常用、最接近实际网络的参考模型 层名 数据格式 协议 应用层 报文 传输层 段 网络层 数据报 链路层 帧 物理层 比特流 6 计算机网络与因特网发展简史 MIT、兰德公司和NPL推动分组交换的研究与发展 分组交换推动因特网的发展 ARPAnet是第一个分组交换的计算机网络，也是当今因特网的祖先 1986年，NSFNET创建，用于商业 20世纪90年代，万维网(www)应用诞生 “互联网+” 二、网络应用(报文)1 计算机网络应用结构1.1 客户服务器(C&#x2F;S)结构网络应用C&#x2F;S结构的特点： 用户与用户之间不进行直接通信 服务器程序需要先运行，客户端后运行 1.2 纯P2P结构网络应用 本质上没有固定的客户端&#x2F;服务器. 1.3 混合网络应用2 网络通信应用通信基本原理2.1 网络应用的基本通信过程 网络应用的基本通信过程就是运行在不同主机上的应用进程间以C&#x2F;S方式进行通信。 2.2 网络应用编程接口(API)典型的应用编程接口是套接字(Socket)，对于传输层协议，需要为其接口的每个套接字分配特定的编号，标识该套接字，该编号称为端口号 3 域名系统(DNS) 域名解析是域名解析为IP地址或者IP地址到域名的反向解析 域名系统会建立分布式数据库，存储域名与IP地址的映射关系数据 3.1 层次化域名空间 层次树状结构命名方式，每个域名由不同级别的域名构成，各个层级域名之间用点分隔 域名级别 分类 所属域名 顶级域名 国家顶级域名 cn,us,uk 顶级域名 通用顶级域名 com,org,gov,edu 顶级域名 基础结构域名 arpa 二级域名 三级域名 四级域名 3.2 域名服务器 根域名服务器：最重要的服务器，全球只有13个。负责指向顶级域名服务器。他们存储的信息为：顶级域名的位置信息，DNS根区文件（包含所有顶级域如：.com、.org、.net等）的名称服务器的地址。 顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。比如：example.com中的“example”的名称服务器的地址。这些名称服务器负责进一步解析二级域名及其下的子域。 权威域名服务器：负责一个区的域名服务器，保存该区中的所有主机域名和IP地址的映射。如A记录(将域名映射到IPV4地址)、AAAA记录(将域名映射到IPV6地址)、MX记录(指向邮件服务器的记录)、CNAME记录(域名别名的记录)、TXT记录(包含文本信息的记录，通常用于验证和安全) 中间域名服务器：不是以上三种的域名服务器。缓存 DNS 记录以加速解析过程。 本地域名服务器：是主机进行域名查询时首先被查询的域名服务器 3.3 域名解析过程 递归解析：代替查询主机或其他域名服务器进行进一步的域名查询，将最终结果发送给查询主机或者服务器。本地域名服务器—-&gt;根域名服务器—-&gt;顶级域名服务器—–&gt;权威域名服务器—–&gt;中间域名服务器。 迭代解析：将下一步要查询的服务器告知查询主机或服务器 4 万维网应用4.1 万维网应用结构 万维网应用包括浏览器、web服务器、HTTP协议 web服务器：用来提供客户机返回响应，已经提供相应页面数据的服务器，通过URL用来给客户机提供对应页面的访问路径。 HTTP协议 Cookie 4.2 HTTP超文本传输协议HTTP连接浏览器像服务器发送请求之前，需要先建立TCP连接，然后才发送HTTP请求，接收HTTP响应报文 非持久连接：请求一次TCP连接，只能请求一次数据，之后就会断开连接，例如：请求携带3个jpg数据的web页面，会耗费8个RTT 并行连接：在单位RTT时间内，建立多条TCP连接，单位RTT时间内，一次请求多条数据，例如：请求携带3个jpg数据的web页面，会耗费4个RTT时间。注意：并行连接会增加客户端主机的资源开销，如内存开销，因此系统通常同时建立的并行TCP连接数有限制，服务器也会对同一客户的并行TCP连接数有所限制。 持久连接： 非流水方式持久连接：客户收到TCP响应报文后，不断开TCP连接，继续依次请求N条数据。例如：请求携带3个jpg数据的web页面，花费5个RTT 流水方式持久连接：客户收到TCP响应报文后，不断开TCP连接，并行请求N条数据，例如：请求携带3个jpg数据的web页面，花费3个RTT HTTP报文： 请求报文 响应报文 起始行 请求行：&lt;请求方法&gt;&lt;URL&gt;&lt;HTTP版本&gt; &lt;HTTP版本&gt;&lt;状态码&gt;&lt;原因短语&gt; 首部行 携带附加信息 携带附加信息 空白行 CRLF CRLF 报文主题 实际要传输的内容 实际要传输的内容 注意：因为HTTP服务器不保存关于客户的任何信息，所以HTTP被称为无状态协议。从而引入Cookie机制，用于用户跟踪。 状态码类别 取值范围 作用 说明 1xx 100-199 信息提示 通告信息，可能还需要进一步交互 2xx 200-299 成功 成功完成客户请求的操作，并进行响应 3xx 300-399 重定向 表示资源已经移走，需要向新URL发请求 4xx 400-499 客户端错误 由于客户端请求错误，无法成功响应 5xx 500-599 服务器错误 由于服务器端错误，无法成功响应 300-名词库/HTTP状态码.mdHTTP状态码 4.3 CookieCookie技术主要包括4部分内容： HTTP响应报文中的Cookie头行 用户浏览器在本地存储、维护和管理的Cookie文件 HTTP请求报文中的Cookie头行 网站在后台数据库中存储、维护Cookie信息：分配给用户ID、每个ID用户在本网站的访问特征等。 5 Internet电子邮件 5.1 电子邮件系统结构 邮件服务器(核心) 用户代理(电子邮件应用的客户端软件) 简单邮件传输协议(SMTP)，默认端口：25 邮件读取协议(POP3,IMPA,HTTP) 5.2 电子邮件格式与MIME注意：传输非7位ASCII码文本内容时，必须依据一个标准将非7位ASCII码文本内容转换为7位ASCII码文本内容，然后在传输，而提供转换功能的是：互联网邮件扩展(Multipurpose Internet Mail Extensions, MIME) 5.3 邮件读取协议POP3: 授权阶段 事务处理阶段 更新阶段IMAP: 互联网邮件访问协议 6 FTP文件传送协议 在互联网的两个主机间实现文件互传的网络应用，其应用层协议称为FTP，并且是属于有状态协议 FTP的服务器进程由两大部分组成： 主进程，负责接受新的客户请求 从属进程，负责处理单个客户请求，与具体客户进行交互。 FTP专门独立建立一个通道用来进行控制信息的传输，与传输文件信息的通道进行分离，所以将FTP这种控制信息的传送方式称为带外控制 7 P2P应用典型应用：BitTorrent&#x2F;PPLive等 P2P应用特点： 应用的对等方是用户的计算机 很强的应用规模伸缩性 应用在对等方之间进行 应用充分聚集利用了端系统的计算能力以及网络传输宽带。 8 Socket 在概念上是通信的端点( end point )。而对于一个传输层协议，需要为其接口的每个套接字分配特定的编号，标识该套接字，该编号称为端口号。套接字是用网络节点的IP地址和端口号来标识的。 Socket可以分成三种类型： SOCK_DGRAM SOCK_STREAM SOCK_RAW scoketAPI函数： socket(): 创建套接字 bind(): 绑定本地端口 listen(): 监听端口 connect(): 连接服务器 accept(): 接收连接请求 send()&#x2F;sendto(): 发送数据 recv()&#x2F;recvfrom(): 接收数据 close(): 断开连接 8.1 基于TCP客户与服务器的典型API函数调用过程 8.2 基于UDP客户与服务器的典型API函数调用过程 三、传输层(报文段&#x2F;数据段) 传输层的核心任务：将应用层传过来的报文封装后，应用进程之间提供端到端的逻辑通信，比如微信，QQ。 1 传输层的功能 对应用层的报文进行分段和重组 面向应用层实现复用与分解(多个客户端可以通过同一种方式给服务器发送请求–&gt;复用；多个客户端可以接收到服务器发送的数据—&gt;分解)。 实现端到端的流量控制 拥塞控制 传输层寻址 对报文进行差错检测 实现进程间的端到端的可靠数据传输 1.1 传输层寻址与端口 不同应用进程用进程标识符(进程ID)来区分 主机之间通过IP+端口号区分不同主机上的应用程序 传输层总共有65536个端口号： 端口 类型 所属机器 0-256 常用端口号 服务器端口号 0—1023 熟知端口号 服务器端口号 1024—49151 登记端口号 服务器端口号 49152—65535 客户端口号(短暂端口号) 客户端口号 1.2 无连接服务与面向连接服务 无连接服务UDP 面向连接服务TCP 数据传输之前：无需与对端进行任何信息交换，直接构造传输层报文段并向接收端发送 数据传输之前：需要与对端进行控制信息交换，建立逻辑连接，然后传输层报文段并向接收端发送，结束后还要拆除逻辑连接 类似于信件通信 类似于电话通信 2 传输层的复用和分解 不同应用进程共用同一个传输层协议，并能够将接收到的数据准确交付给不同的应用进程，称为传输层的多路复用与多路分解 多路复用：传输层可以从不同的套接字接收不同应用进程传输过来的报文，并给每个报文封装上首部信息(包括用于分解的信息)构成报文段，然后将报文段传给网络层。多路分解：在目的主机，传输层协议读取报文段中的字段，标识出接收套接字，进而通过该套接字，将传输层的报文段中的数据交付给正确的套接字。 2.1 基于UDP的复用和分解 Internet提供无连接服务的传输层协议。 300-名词库/UDP.mdUDP UDP套接字二元组： &lt;目的IP地址，目的端口号&gt;UDP套接字分配端口号的两种方法： 创建一个套接字，传输层自动为套接字分配一个未被使用的端口号(1024-65535之间) 在创建一个UDP套接字后，通过bind()方法为该套接字绑定一个特殊的端口号。 2.2 基于TCP的复用和分解 Internet提供面向连接服务的传输协议额 300-名词库/TCP.mdTCP TCP套接字四元组：&lt;源IP地址，源端口号，目的IP地址，目的端口号&gt; 3 停-等协议与滑动窗口协议3.1 实现可靠数据传输基本措施(5种) 肯定确认ACK&#x2F;否定确认NAK 差错校验 重传 序号 计时器 1234title: 数据传输过程中可能发生的错误：1. 比特差错2. 乱序3. 数据丢失 3.2 停-等协议(简单的ARQ协议) 是OSI模型中针对传输层和数据链路层的错误纠正协议之一，用来解决数据丢失、比特差错、乱序。同时也是TCP实现可靠传输的重要协议。 300-名词库/ARQ.mdARQ 什么是停-等协议？ 发送方每发送一个报文段，就会等待接收方返回一个收到确认。收到ACK就会仅需发送下一个报文段，如果收到NAK就会重传刚刚发送的报文段。接收方收到一个报文段，就会进行差错检测无误且序号正确，就会接收报文段，并返回给发送方一个ACK 涉及解决措施：ACK、NAK、超时 缺点： 性能差。 对信道的利用率不高。 细节讨论： 差错控制：报文段、ACK、NAK数据包均需要进行差错编码以便进行差错控制 。 序列号：停-等协议只需要一位用来表示是新发的还是重传的。 ACK和NAK：一般来说会用ACK替代NAK，比如传输一个报文0，正确就会返回ACK0，在传输一个报文1，出现错误就会返回ACK0表示，目前只有上一个是正确的。 3.3 滑动窗口协议(流水线协议) 什么是流水线协议？ 允许发送方在没有收到确认前连续发送多个分组，从发送方 向 接收方 传送的系列分组可以堪称是填充到一条流水线(管道中)。 300-名词库/流水线协议.md流水线协议 滑动窗口协议：发送方对数据包进行编号，允许发送多个分组，响应接收到多个分组只会返回ACK，如果没收到 通过计时器，发送发默认再次发送。 发送窗口(Ws): 发送方可以发送未被确认分组的最大数量。接收窗口(Wr): 接收方可以缓存的正确到达的分组的最大数量。 滑动窗口协议根据窗口大小可分为： (GBN)回退协议：发送窗口Ws&gt;&#x3D;1 ,接收窗口Wr&#x3D;1，发送方缓存能力高，可在没有得到确认前发送多个分组，接收方缓存低，不能缓存未按序到达的分组。比较适合误码率低、丢包率低、带宽高时延积信道，且对接收方缓存能力要求低。示例：发送方收到【6-10】号的确认，那么发送窗口就可以进行滑动。收到7，就滑动到 8号，收到10，不论6、7、8、9是否收到，都可以进行滑动到11号分组去。 (SR)选择重传协议：发送窗口Ws&gt;1，接收窗口Wr&gt;1，发送方发送多个分组，接收方只会接收窗口左侧及窗口里面序号的分组，其余序号的分组都会进行丢弃。 4 用户数据报协议(UDP) Internet提供无连接服务的传输层协议。 300-名词库/UDP.mdUDP 12345title: 为什么要选择UDP呢？1. 应用进程**容易控制**发送什么数据以及何时发送，但是会出现分组的丢失和重复。2. **无需建立连接**3. 无连接状态4. **首部开销小，只有8个字节** 1234title: 请描述一下UDP的首部报文结构：![[Pasted image 20230405000813.png]]1. UDP首部**四个字段**：每个字段长度都是2个字节，一个字节\\=\\=&gt;8位\\=\\=&gt;8bit。2. 源端口号和目的端口号用来实现复用和分解----&gt; [[# 2 传输层的复用和分解]] 1234title: 由首部报文结构得知**UDP校验和**，那么UDP校验和又是什么？为了能够计算校验和，需要在UDP报文上添加一个**伪首部**，伪首部不进行上下层的传输，只有在需要进行校验时才会生成(当接收主机在收到UDP报文以后，从**IP首部**获悉IP地址信息**构造**UDP伪首部。)在进行校验和计算,而伪首部由四个部分组成：源IP、目的IP、填充、协议号、UDP包长度。![[Pasted image 20230405001520.png]]![[Pasted image 20230405001817.png]] UDP校验和计算： 所有参与运算的内容按16位对齐求和。 求和过程中遇到溢出都会被回卷(即进位与和的最低位再相加)。 将求到的和取反码，就是UDP的校验和，填入UDP数据报的校验和字段 注意：UDP在生成校验和时，校验和字段全取0 5 传输控制协议(TCP)5.1 TCP报文段结构 Internet提供面向连接服务的传输协议额 300-名词库/TCP.mdTCP TCP的特点： 应用进程先建立连接。 传输数据：无差错、不丢失、不重复、按序到达。 面向字节流：应用程序和TCP的交互是一个个数据块，可把他们看作是无结构字节流。 全双工通信：通信双方进程在任何时候都能发送和接收。 TCP报文段结构：首部字段和一个数据字段组成。(将文件划分成长度为MSS的块，最后一块除外)，一个块封装成一个TCP报文段。 TCP一个报文段的结构： 序列号字段(32位)：TCP的序号是对每个应用层数据的每个字节进行编号. 确认序号字段(32位)：是期望从对方接收数据的字节序号，即该序号对应的字节尚未收到，用ack_seq表示 TCP段首部长度最短是20字节 TCP的6个标志位: – – 紧急URG 置1时表示紧急指针有效，优先传送。 确认ACK 置1时表示确认序号有效 推送PSH 置1时表示接收方收到数据段后应该尽快送到应用程序 重置RST 置1时表示重新建立连接 同步SYN 置1时表示发起一个连接 终止FIN 置1时表示发送方完成发送任务，释放连接 6. 接收窗口字段：16位。向对方通告我方接收窗口的大小。实现TCP流量控制。 7. 检验和字段：16位。计算方法与UDP校验和的计算方法相同—-&gt;[[# 4 用户数据报协议(UDP) &gt; 4 用户数据报协议(UDP)]] 8. 紧急指针字段：16位。URG为1时有效。 5.2 TCP连接管理连接建立： sequenceDiagram 服务器-->>服务器: CLOSED--->LISTEN 客户端->>服务器:我能跟你建立连接嘛?SYN=1,SEQ=x 客户端-->>客户端:CLOSED--->SYN_SENT(同步发送) 服务器->>客户端:同意建立连接,同意建立新连接SYN=1,确认接收到ACK=1序号有效准备接收下一个的包的序号是x+1,并且告知确认报文段的序号为y。 SYN=1,ACK=1,SEQ=y,ACK_SEQ=x+1 服务器-->>服务器:Listen--->SYN_RCVD(同步收到) 客户端->>服务器:你同意连接这个消息我确认接收到了。ACK=1,SEQ=x+1,ACK_SEQ=y+1-->B 客户端-->>客户端:发送ACK时，SYN_SENT--->ESTABLISHED 服务器-->>服务器:收到ACK时，SYN_RCVD--->ESTABLISHED 12345title: 为什么需要三次握手？第一次握手：客户端发送请求，服务器知道客户端能**发**。第二次握手: 服务器发送确认，客户端知道服务器能**收**。第三次握手：客户端发送确认，服务器知道客户端能**收**。 传输字符代表什么意思呢？ SYN&#x3D;1: 建立连接请求控制段。seq&#x3D;x：表示传输的报文段的第1个数据字节序列号时x，此序列号代表这个报文段段的序号。ACK&#x3D;1：确认序号字段有效seq&#x3D;y：服务器告诉客户机确认报文段的序列号是y。ack_seq&#x3D;x+1：表示已经收到了序列号为x的报文段，准备接收序列号为x+1的报文段。seq&#x3D;x+1：客户机此次的报文段的序列号是x+1.ack_seq&#x3D;y+1：客户机期望接收服务器序列号为y+1 连接拆除： sequenceDiagram 客户端->>服务器:我需要请求拆除连接,FIN=1,SEQ=u 客户端-->>客户端:ESTABLIST--->FIN_WAIT_1 服务器->>客户端:我同意拆除连接，但是还有数据没有传完 服务器-->>服务器:ESTABLIST--->CLOSE_WAIT 客户端-->>客户端:FIN_WAIT_1--->FIN_WAIT_2 服务器->>客户端:我的数据发完了，拆除连接 服务器-->>服务器:CLOSE_WAIT--->LACK_ACK 客户端->>服务器:好的，收到，确认断开。 客户端-->>客户端:FIN_WAIT_2--->TIME_WAIT Note over 客户端:等待一段时间 客户端-->>客户端:TIME_WAIT--->CLOSED 服务器-->>服务器:LACK_ACK--->CLOSED 5.3 TCP可靠数据传输 TCP实现可靠数据传输服务的工作机制： 可靠:保证接收方进程从缓冲区读出的字节流与发送方发出的字节流是一样的。 序号：应用层数据被分割成TCP认为最适合发送的数据段，一个字节占用一个序号。 确认：TCP采用累计确认，此时返回发送端发送的序号x+1 重传：快速重传 计时器：规定时间段没有收到确认报文段，就进行重传，1个加权+4✖偏差* 5.4 流量控制12title: 什么是流量控制？是指控制主机的发送速率和发送报文的数量。 123title: 如何做到流量控制呢通过发送TCP报文的**缓存窗口大小** 5.5 拥塞控制TCP的拥塞控制是指：当多台主机以极快的速率向同一个通道发送数据，其中控制传输层通道传输的数据，有效减少传输性能下降。 那么如何进行TCP拥塞控制呢？在进行讲解拥塞控制之前需要先了解三个概念： 慢启动：慢启动是指，刚开始时，拥塞窗口只能为1MSS，当经过一个RTT时间，拥塞窗口会增长 一倍，直到遇到阈值才会改变 拥塞避免：当拥塞窗口遇到阈值，就会进行拥塞控制模式，在一个RTT时间内拥塞窗口会进行线性增长，一次+1. 快速重传：当网络出现三次重传的情况下，推断重复确认的报文段丢失了，就会立即发送重复确认的报文段。 快速恢复：当网络出现三次重传的情况下，但是拥塞不是很严重的情况下，重新设置的窗口不在从慢启动开始，而是从新的阈值开始，直接进入拥塞避免阶段。 了解了拥塞控制的基础运用后，现在就可以讲解什么情况下会进行拥塞控制？ 发生三次重复确认时，当前拥塞窗口为24MSS，当前阈值为16MSS,立即发送重复确认的报文段。新的阈值：为当前拥塞窗口的一般24MSS&#x2F;2&#x3D;12MSS.新的拥塞窗口：调整为新的阈值，即12MSS 发生计时器超时，就会任务拥塞严重。就会将拥塞窗口置为1，并且进行慢启动和拥塞避免阶段。 6 总结传输层的功能有哪些？ 对应用层的报文进行分段和重组。 面向应用层实现复用与分解。 实现端到端的流量控制。 拥塞控制 传输层寻址 对报文进行差错检测。 实现进程间的端到端可靠数据传输控制 如何对应用层的报文进行分段和重组呢？ 应用层实现复用和分解是怎么做的？ 将各个应用包的数据统一进行封装，发送给接收方，接收方根据首部进行分发给各个程序 如何实现端到端的流量控制呢？ 通过ARQ协议和流水线协议。自动重传协议典型的代表又有停-等协议。流水线协议的经典实现为滑动窗口协议，滑动窗口协议又分为 回退N步协议 和 选择重传协议(SR). 他们之间又是通过拥塞窗口的大小进行区分的。 如何对报文进行差错检测呢？ 通过校验码进行检测的。通过计算16位二进制码的和的反码从而进行差错检测。 端到端的可靠数据传输协议又是如何实现的呢？通过：1. 确认&#x2F;否认。2. 计时器 3. 差错检测 4. 重传 5. 序号。基于这五种措施从而得到停-等协议和滑动窗口协议。 为什么UDP明明不可靠，但是还是有程序要用呢？ 因为使用门槛小，开销小，对于一些程序对数据的可靠性传输要求不高的情况下，UDP更好用。 TCP是如何进行三次握手和四次挥手的？ 请求方发送请求连接。 接收方收到请求连接后，返回一个确认报文，表示我收到了，可以建立连接。 请求方收到确认报文，就会给接收方发送一个建立连接报文。 请求方不在使用后，就会给接收方发送一个拆除连接的请求。 接收方收到拆除连接的请求后，就会给发送方返回一个确认报文，并且将没传完的数据传完。 接收方将数据传输完毕后，就会再给发送方发送一个断开连接报文。 发送方收到断开连接报文，会等待一会。然后确认断开连接。 TCP是如何是如何实现可靠数据传输的呢？ 将应用层数据分割成TCP认为合适的数据块(MSS),封装成TCP段，发送给IP 计时器。发送一个TCP段，就会启动一个计时器。 TCP的首部也设置有校验和字段。检测数据传输过程中可能出现的差错。 序号标识每一个传输的TCP段，保证TCP段按序发给IP。 接收方可以通过序号丢弃重复TCP段。 TCP能够提供流量控制，分配一定大小的接收缓冲空间。 TCP如何实现流量控制的呢？ 通过算法,算法如下所示： 慢启动。 拥塞避免。 快速重传。 快速恢复。 四、网络层1 网络层服务 网络层有什么用？ 将传输层发送过来的报文段封装成IP数据报发给目的地址。实现数据转发、路由选择、建立连接。 那么如何实现的呢？首先发送数据有两个方式： 2 虚电路和数据报交换 项目 虚电路交换 数据报交换 是否建立连接 是 否 地址 每个分组含有一个虚电路号 每个分组包含源和目的IP地址 分组顺序 依次发送，按序接收 按序发送，不按序到达 路由选择 建立VC时需要路由选择，之后所有分组都沿着此路由转发 每个分组独立选择 典型网络 X.25,帧中继，ATM 因特网 由于数据报交换不是按序到达，所以把排序分组的任务交给了传输层来进行处理。 虚电路交换和数据包交换的区别是什么？ 虚电路是把顺序控制、差错控制、流量控制本身来完成这些操作。数据报交换 是把 顺序控制、差错控制、流量控制交给网络节点来完成，本身只做转发、路由的操作。 3 异构网络互联与网络互联设备现在说完了发送数据的方式，那么再来说说组成数据的单位，一般来说，我们将4G,5G,wifi等数据网络类型进行连接通信交换数据的方式称为异构网络互联，其中能够进行异构网络互联的代表机器有：路由器。 那么路由器又由什么构成的呢？ 输入端口：用来查找和，转发，发送数据 交换结构：用来实现具体的转发操作,性能由高到低排序： 网络交换 总线交换 内存交换 输出端口：缓存排队，从队列中取出分组进行数据链路层的数据帧的封装、发送。 **先到先服务(FCFS)**调度策略 按照优先级调度。按IP数据报的服务类型(Tos)调度 处理器：执行命令，路由协议允许，路由计算和路由表的维护。 知道了上述构成后，那么路由器如何执行路由匹配呢？ 没有匹配成功的路由，会选择默认路由进行转发。 匹配成功的路由，会选择该路由项对应的输出端口进行转发。 有多条路由匹配成功，遵循网络前缀匹配成功位数最长的路由项进行转发，即最长前缀匹配优先原则。 4 网络拥塞 网络拥塞是指：一种持续过载的一种网络状态，当用户对网络资源(包括链路带宽，存储空间和处理器处理能力)的总需求超过整个网络的固定资源容量。 123title: 那么我们如何判断网络是否存在拥塞呢？1. 吞吐量：越大越好2. 响应时间：越短越好 123456title: 一般什么情况下会发生网络拥塞呢？- 缓存区容量有限- 传输线路的带宽有限- 网络节点的处理能力有限- 网络中某些节点出现了故障 如何解决上面所说的网络拥塞呢？ 流量感知路由：通过将网络抽象成一个带权无向图，其中权值能够根据网络链路负载情况而发生改变，从而平衡网络性能或者减少网络拥塞的发生，但是该方法可能会造成振荡现象 准入控制：专门针对虚电路设置的一种处理方式，每次有新的VCID要接进来时，就会判断是否会出现拥塞，不会出现就会允许接入。 流量调节 抑制分组：当报文发送到某一条链路时，发现当前链路存在拥塞，则会根据源主机地址返回改报文，并一路标识该链路存在拥塞,通过ICMP协议可实现该操作。 背压：是指返回这个报文的路上经过提示的路由器称为背压。 负载脱落：当链路出现拥塞会自动进行丢弃分组，从而减少链路负载压力 5 Internet网络层讲解一下Internet网络层的组成： 网际协议(Internet Protocol，IP) IPv4：是网络层最核心的协议，定义了如何封装上层应用，定义了网络层寻址以及如何转发IP数据报等内容 IPv6 路由协议 互联网控制报文协议 在述说网际协议时，有讲一个核心协议IPv4，那么我们说一下IPv4的报文格式，如图所示： 报文字段 长度 作用 版本号 4位 IPv4、IPv6 首部长度 4位 区分服务 8位 在旧标准种称为服务类型(Type Of Service,TOS)字段，用来指定期望获得哪种类型的服务。 数据长度 16位 指出IP数据报的总字节数 生存时间 8位 标识IP数据报在网络中可以通过路由器数(或跳步数) 上层协议 8位 指出该IP数据报封装的哪个上层协议，TCP&#x2F;6，UDP&#x2F;17 首部校验和 16位 利用校验和实现对IP数据报首部的差错检测 源IP地址 32位 目的IP地址 32位 选项 长度可变 数据 标识 16位 标识一个IP数据报 标志 3位 DF(Don’t Fragment禁止分片标志)&#x2F;DM(More Fragment,更多分片标志) ，MF&#x3D;0表示未分片或者是最后一片 片偏移量 8B 表示一个 IP数据报分片与原IP数据报数据的相对偏移量，当该字段为0时，且MF&#x3D;1，则表示这是第一个分片 由于数据链路层可以传输的数据大小有限，那么就需要将IP数据报进行分片。其中传输层的最大传输单元(MTU) 如何分配呢？示例：目前要传输一个总长度为3400字节的IP数据报，通过MTU&#x3D;1500字节的链路进行转发。如何分片？ 计算数据总长度：3400-20&#x3D;3380字节。20字节为数据报首部字节长度 计算分片可以携带的数据总长度：1500-20&#x3D;1480字节。20字节为数据报首部字节长度 计算要分几片：3380&#x2F;1480&#x3D;2.2838片，得出要分三片。 则DF标志和MF标识为：0 1,0 1,0 0。 每片要携带的数据字节数：1480字节(0-1479)，1480字节(1480-2959)，420字节(2960-3379) 每片的总字节数：1500字节，1500字节，440字节。 每片的偏移量：0&#x2F;8&#x3D;0，1480&#x2F;8&#x3D;185，2960&#x2F;8&#x3D;370 现在讲解一下IP地址的编址4个字节组成IP地址，并且对IP地址进行划分 地址级别 前缀长度 首字节 作用 A类 8位 0-127 标识服务器或路由器 B类 16位 128-191 标识服务器或路由器 C类 24位 192-223 标识服务器或路由器 D类 不可用 224-239 组广播地址 E类 不可用 240-255 地址保留 5.1 IPv4编址我们通过子网掩码进行规划整个网段的机器数量并且我们还可以把较大的子网在划分成多个小子网，这个操作称为子网化将多个小的子网合并成一个大的子网，这个操作统称为超网化 示例：假设某子网中的一个主机的IP地址是203.123.1.135，子网掩码是255.255.255.192，那么该子网的子网IP是多少？直接广播地址是多少？该子网的IP总数是多少？该子网可分配IP地址数是多少？可分配IP地址范围是多少？子网地址&#x3D;203.123.1.135转换成二进制 &amp;&amp; 255.255.255.192 转换成二进制 进行**与运算(1&amp;0&#x3D;0,1&amp;1&#x3D;1, 0&amp;1&#x3D;0，0&amp;0&#x3D;0)，从而得到 203.123.1.128广播地址：203.123.1.135转换成二进制 &amp;&amp; 255.255.255.192 转换成二进制 进行或运算(1&amp;0&#x3D;1, 1&amp;1&#x3D;1, 0&amp;1&#x3D;1, 0&amp;0&#x3D;0)**，从而得到 203.123.1.191 当我们得知主机IP地址，如何得到子网地址和广播地址呢？ 子网掩码和主机地址按位做与运算就可以得到子网地址。子网掩码的反码和主机地址按位做或运算就可以得到直接广播地址然后在计算具体的可分配的地址数量时，可根据掩码进行计算，例如掩码26位，所以可分配的主机地址为：2的(32-26)次方-2，其中这个-2是由于要扣除子网地址和直接广播地址 那么由于路由器有路由选择功能，那么如何让路由表不臃肿呢？这时候就要用到路由聚合的功能，它可以将同网段的子网聚合成一个大的子网，即超网化。 那么如果我们存在一个新的终端，没有配置IP地址如何做到通信呢？这时候就要用上动态主机配置协议了 5.2 差错控制报文 在主机或路由器之间实现差错信息控制、信息探测，例如ping的实现 300-名词库/ICMP.mdICMP ICMP报文可以分成两种： 差错报告报文 终点不可达 源点抑制 时间超时 参数问题 路由重定向 询问报文 回声请求&#x2F;应答 时间戳请求&#x2F;应答 5.3 IPv6IPv6由128位组成，其中可分为： 单播地址：源和目的地址。 组播地址：标识一组主机，可以作为目的地址。 任播地址：标志一个组内的所有主机，作为目的地址。 并且当存在8000:0000:0000:0000:4321:0000:0000:56CD ，可用8000::4321:0000:000056CD表示，每个IPv6地址有且仅有一个::符号 在IPv6的数据传输中，万一出现中间路段是由IPv4组成的路段这时就要用上隧道技术，用来很好的解决IPv6通信中经过IPv4路由器的问题，并且也不会出现信息丢失的问题。 5.4 路由选择算法与路由协议我们先讲解基础算法，并进行分类 全局式路由选择算法 全局式路由选择算法：链路状态路由选择算法LS（算法：Dijkstra算法） 分布式路由选择算法：距离向量路由选择算法DV（算法：D-F方程） 静动态路由算法 动态路由算法：LS和DV都是动态路由算法 静态路由算法 是否敏感 说明了基础算法，那么现在说说网络组网的一些问题，一般来说一个大型的网络只靠单一的路由算法是无法很好的发挥性能的，这是我们就需要将一个大型网络划分成一个个小型的网络，这种方法称为层次化路由选择，每一个运行相同路由选择算法和相同路由协议的小型网络就是一个自治系统(autonomous system AS)，所以一个网络是由一个个自治系统互联组成的。而我们根据在自治系统内外运行的协议进一步划分，我们将在自治系统内运行的协议统称为IGP(Interior Gateway Protocol,内部网关协议)，在自治系统外运行的路由协议额统称为**EGP(Exterior Gateway Protocol,外部网关协议)**。 IGP RIP:通常运行在较小的AS中 OSPF:运行在较大的AS中 EGP BGP:运行在自制系统间的路由协议，主要作用交换域间路由协议； 5.4.1 RIP协议 基于距离矢量算法（Bellham-Ford）（DistanceVectorAlgorithms），使用“跳数”(即metric)来衡量到达目标地址的路由距离，不能超过15跳，基于距离向量路由选择算法。 5.4.2 OSPF协议 目前使用较多的路由协议OSPF（Open Shortest Path First，开放最短路径优先）,是IETF（Internet Engineering Task Force，互联网工程任务组）组织开发的一个基于链路状态路由选择算法的自治系统内部网关协议，OSPF直接将报文封装在IP报文中。 5.4.3 BGP 边界网关协议。实现跨自治系统的路由信息交换。BGP封装进TCP报文段中，BGP也是由应用进程实现的，通过179号端口建立半永久的TCP连接。 每个AS可以通过BGP实现如下功能： 从相邻的AS获取某子网的可达性信息。 向本AS内部的所有路由器传播跨AS的某子网的可达信息。 基于某子网的可达信息和AS路由策略，决定到达该子网的最佳路由。 6 总结五、数据链路层 负责通过一条链路，从一个结点向另一个物理链路^1直接相连的相邻结点，传输网络层数据报，中间不经过任何其他交换结点。 提供的服务： 组帧(成帧) 链路接入 可靠交付 差错控制 检错重发 前向纠错 反馈校验 纠错丢弃 什么是组帧？ 数据链路层将要传输的数据(网络层IP数据报)封装成帧，称为组帧或者成帧。帧头(帧首)：发送结点和接收结点的地址(MAC)信息。帧尾：用于差错检测的差错编码。帧定界：识别一个帧的开始和结束，用01111110。 什么是链路接入？ 物理链路分为：点对点链路和广播链路。点对点链路：发送结点和接收结点独占信道链路。广播链路：通信链路被多个结点共享，会彼此干扰，导致传输失败。 可靠交付如何做到？ [[#3 停-等协议与滑动窗口协议| &gt; 3 停-等协议与滑动窗口协议]]可适用。无线链路(出错率高)：需要可靠数据传输能力。光纤、双绞线(出错率)：不提供可靠数据传输服务。 差错控制如何做到？ 数据链路层帧在物理媒介上的传播过程，可能会出现比特翻转的差错。与线路信噪比有很大的关系。 1 差错控制 为什么会发生差错控制？ 信号在传输过程中，会受到各种噪声^2的干扰，从而导致传输差错。 什么是差错控制？ 通过差错编码技术，实现对信息传输差错的检测，并基于某种机制进行差错纠正和处理。 差错控制的基本方式： 检错重发：接收端利用差错编码检测到错误数据，就会重发数据加以纠正。[[#3 停-等协议与滑动窗口协议| &gt; 3 停-等协议与滑动窗口协议]] 前向纠错：对帧进行检错、定位、对错误的帧进行纠正 反馈校验：接收端会将数据返回给发送端，由发送端确定，不同就重传数据。 检错丢弃：检测到错误数据，就丢弃。适用于实时性较高的系统。 差错编码的基本原理：在待传输的信息基础上，附加一定的冗余信息。 不同的差错编码的检错和纠正能力是通过什么凸显不同的？ 跟编码集的汉明距离^3 有关。编码集：差错编码的所有有效码字的集合。编码集的汉明距离：是指编码集中任意两个码字之间汉明距离的最小值。例：{10000111,10010110, 10100101, 10110100}。汉明距离ds &#x3D; min{2,2,4,4,2,2}&#x3D;2 检错：编码集的汉明距离Ds&#x3D;r+1，则该差错编码可以检错r位的差错。例如：发送2为数据信息，冗余信息是数据的一次复制。编码集：{0000, 0101, 1010, 1111}, ds&#x3D;2(2即1+1，r为1) 纠错：编码集的汉明距离Ds&#x3D;2r+1,则该差错编码可以纠错r位的差错。例如：发送2为数据信息，冗余信息是数据的两次复制。编码集：{000000, 010101, 101010, 111111}, 则可以检测几位的差错？ds&#x3D;3(3即2*1+1，r为1)如果收到100010，则有效码字应该是？将100010与编码集计算汉明距离，取最小汉明距离，则恢复成101010 几种典型的差错编码： 奇偶校验码：奇校验码是当编码中的1为奇数时，编码尾巴添加一个码字为0，反之亦然。 偶校验码使编码中的码字 1 的个数为偶数个.例如：10110111—奇校验—-&gt; 101101111例如：10110111—偶校验—-&gt; 101101110 循环冗余码( Redundancy Check,CRC码)：将二进制位串看成系数为0或1的多项式的系数。 循环冗余码的计算方式： 假设CRC编码采用的多项式G(X)&#x3D;X⁴+x¹+1,请为位串10111001进行CRC编码。 整理得多项式：1X⁴+0X³+0X²+1X¹+1X⁰ 写出多项式对应的位串：10011 查看多项式得到得位串有多少位，得到：5-1 &#x3D; 4，所以需要在待编码位串后面添加0的个数：添加4个0，10111001—–&gt;101110010000 用得到的新的待编码位串除以(异或运算)^4多项式对应的比特串。 用求得的余数(CRC码)放到待编码位串后面。 接收端如何判断是否有错 用收到的串除以多项式对应的比特串。余数为0，无错，反之亦然。 2 多路访问控制协议 数据链路层使用几种信道？ 点对点信道，一对一通信方式，信道被双方共享 广播信道，一对多通信方式，信道上连接的点很多，信道被结点共享。其中代表协议有多路访问控制（Multiple Access Control,MAC） 那么什么是多路访问控制？ 采用一定的措施，使得结点间的通信不会发生干扰的情况，解决信道的共享问题。而MAC协议的根本任务：协调结点的数据发送，解决信道的共享问题。 多路访问控制又分为： 信道划分MAC协议：利用多路复用技术实现信道共享的MAC协议。 频分多路复用（FDM）:给信道划分多个范围频率，让不同的结点在一个信道中，用不同频率进行传输数据，在模拟通信电路中应用广泛。缺点是：不容易性能监控、信号之间相互干扰。 同步时分多路复用&#x2F;异步时分多路复用（TDM&#x2F;ATDM）：将通信信道的传输信号划分为多个等长的时隙，每路信号占用不同的时隙。使多种信号合用单一的通信信道在时域上不重叠，从而实现信道共享。 波分多路复用（WDM）：实质是一种频分多路复用。广泛用于光纤通信^5，在光纤通信中，光载波频率很高，通常用光的波长来代替频率讨论，所以叫做波分多路复用。 码分多路复用（CDM）：是一种扩频的通信形式 随机访问MAC协议：所有用户都可以根据自己的意愿随机地向信道上发送信息。当产生冲突或碰撞时，每个用户随机退让一段时间后，再次尝试，直至成功。 纯ALOHA：最早最基本的无线数据通信协议，任何一个站点有数据发送时就可以直接发送至信道。发送数据后对信道进行侦听。性能要求：S吞吐量^6，G网络负载^7，网络负载不能大于0.5。 时隙ALOHA：把信道时间划分为离散的时隙，每个时隙为发送一帧所需的时间，每个通信站点只能在每个时隙开始发送帧。如果在一个时隙内发送帧出现冲突，下一个时隙以概率p重发该帧，知道帧发送成功。p不能为1，否则会出现死锁。性能要求：网络负载不能大于1 载波监听多路访问协议：”先听后说” 非坚持CSMA：先侦听，空闲发送，忙时等待随机时间，重新开始侦听，减少冲突，增加了信道的空闲时间。 1-坚持CSMA：先侦听，如空闲，就发送，否则一直侦听，一旦信道空闲，就会立即发送。减少信道空闲时间。增加冲突概率。 P-坚持CSMA：先侦听，如空闲发送，则以概率P在最近时隙开始时刻发送数据，以概率Q&#x3D;1-P延迟至下一个时隙发送。如果下一个时隙依旧信道空闲，那么就将重复上面过程，直到时隙被其他通信站占用；若信道忙，就等待下一个时隙，重新开始发送；若发送数据出现冲突，就会等待一个随机时间，重新开始发送。 带冲突检测的载波监听多路访问协议（CSMA&#x2F;CD） :通信站使用CSMA协议进行数据发送，在发送期间如果能检测到碰撞，立即终止发送，并发出一个冲突强化信号，使所有通信站点都知道冲突的发生，然后等待一个随机时间，再重复上述过程。工作状态分为三种：传输周期、竞争周期、空间周期。并且信道也有3种状态：传输状态、竞争状态、空闲状态。在使用CSMA&#x2F;CD协议实现多路访问控制时，需要满足下列约束关系：数据帧最小长度&#x2F;信息传输速率 ≥ 2两通信站之间的最远距离&#x2F;信号传播速度。 受控接入MAC协议：各个用户不能随意接入信道，必须服从控制 集中控制式：系统有个主机负责调度其他通信站接入信道，从而避免冲突。方法 轮询。 轮叫轮询：从站1开始，站1如果有数据就发给主机，无数据则发送控制帧，然后主机轮询站2，以此类推。 传递轮询： 分散控制式：方法是令牌技术，在信道空闲时，一直在信道上传输。一个通信站想要发送数据必须首先获得令牌。令牌丢失和数据帧无法撤销是环网上最严重的两种错误。 2.1 局域网 局域网有什么特点？ 局部区域网络、覆盖面积小、网络传输速率高、传输误码率低。 局域网常见的拓扑类型： 星形、总线型、环形网络等。 为了使数据链路层更好地适应多种局域网标准，1EEE802委员会将局域网的数据链路层拆分为两个子层： 逻辑链路控制（LogicalLinkControl，LLC）子层（名存实亡） 介质访问控制（mediumaccesscontrol，MAC）MAc子层 数据链路层如何将帧发给目的地址呢？ 数据链路层的帧需要携带发送结点的数据链路层地址，以及接收结点的数据链路层地址（MAC地址），标识帧的发送方与接收方。 什么是MAC地址？ MAC地址（物理地址、局域网地址）：MAC地址具有唯一性每个网络适配器对应一个MAC地址。MAC地址空间的分配：由电气和电子工程师协会（IEEE）统一管理。IEEE分配前24位的MAC地址块。后24位由生产公司分配。 如何表示MAC地址？ 以太网和IEEE802.11无线局域网，使用的MAC地址长度为6字节（48位）。一共有2⁴⁸个可能的MAC地址。通常采用十六进制表示法，每个字节表示一个十六进制数，用－或：连接起来：例如:00-2A-E1-76-8C-39 或00:2A:E1:76:8C:39【十六进制：0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F】 如何获取到MAC地址呢？ ARP：在本网内，根据目的主机或默认网关的IP地址获取其MAC地址。 地址解析协议的基本思想： 地址解析协议的基本思想：在每一台主机中设置专用内存区域，称为ARP高速缓存（也称ARP表）。存储该主机所在局域网中其他主机路由器的IP地址与MAC地址的映射关系。ARP通过广播ARP查询报文，来询问某目的IP地址对应的MAC地址，即知道本网内某主机的IP地址，可以查询得到其MAC地址。 关于ARP注意的两点： ARP查询分组是通过一个广播帧发送的；而ARP响应分组是通过一个标准的单播帧发送的。 ARP是即插即用的，一个ARP表是自动建立的，不需要系统管理员来配置。 ARP和DNS有什么区别？ 解析内容不同,DNS在应用层，域名解析成IP。而ARP是在数据链路层，ARP将IP地址解析成MAC地址。 解析范围不同：DNS可以解析internet内任何位置的主机域名；而ARP只为在同一个子网上的主机和路由器接口解析IP地址。 实现机制不同：DNS是一个分布式数据库，需要在层次结构的DNS服务器之间查询；ARP通过局域网内广播查询，维护ARP表，获取同一子网内主机和路由器接口的IP地址与MAC地址的映射关系。 以太网成功的原因？ 以太网是第一个广泛部署的高速局域网。 令牌环网、FDDI（纤分布式数据接口）和ATM（异步传输模式）等比以太网技术更复杂、昂贵，阻止了网络管理员改用其他技术。 以太网数据速率也快，比起其他技术，毫不逊色。 以太网硬件价格极其便宜，网络造价成本低。 经典的以太网技术有哪些？ 采用粗同轴电缆连接的总线型以太网（10Base-5）（10：10Mbit&#x2F;s；BASE：传输信号为基带信号；5：5个网段、单段最大传输距离为500米）。 数据传输速率为10Mbit&#x2F;s，无连接不可靠。 MAC协议采用CSMA&#x2F;CD协议。 相距最远主机信号往返的传播时延为51.2uS，所以以太网最短帧长为64字节。 以太网帧结构 目的地址和源地址：48位MAC地址 类型：标识上层协议。例如：0x0800&#x3D;1P数据报 数据：封装的上层协议的分组 CRC：校验采用循环余校验，4字节注意：无连接服务：发送数据帧之前没有握手。不可靠服务：丢弃无效的MAC帧，没有重传等措施。 分类 传输介质 传输速率 标准 10Base-T 非屏蔽双绞线(UTP) 10Mbit&#x2F;s IEEE 802.3 100Base-T（快速以太网） 非屏蔽双绞线(UTP) 100Mbit&#x2F;s IEEE 802.3u 千兆位以太网 光纤、UTP、屏蔽双绞线（STP） 1000Mbit&#x2F;s IEEE802.3标准的扩展 万兆位以太网 10Gbit&#x2F;s IEEE802.3ae 交换机的基本工作原理： 当一帧到达时，交换机首先需要决策时丢弃还是转发。如果是转发的话，还必须进一步决策应该将该帧转发到哪个端口去。决策依据：以目的MAC为主键查询内部MAC表(无需转发、选择性转发、泛洪) 交换机如何学习组建内部MAC转发表呢？ A向B发送一个数据帧。 交换机查询转发表，没找到往哪里发该帧。 交换机就把这个帧的源MAC地址A和端口1写入转发表，完成第一次学习。 交换机向除端口1以外所有端口泛洪(广播)这个帧， C和D丢弃该帧。B收下该帧。 从而依次组建。注意：端口连接的主机更换了，需要更新交换表的内容。失效的项目会自动更新。 交换机有什么优点？ 消除冲突：交换机分割了冲突域，交换机具有缓存机制，某一时间点传输一个帧或者不传输；与集线器不一样。 支持异质链路：交换机的多个端口，可以连接多种不同的链路，例如接口1连接10Mbit&#x2F;s的10BASE-T双绞线；接口2连接1Gbit&#x2F;s的1000BASE-LX光纤。 网络管理：检测到一个异常的适配器。把适配器隔离，不需要管理员手动隔离。 虚拟局域网：数据链路层交换机互联的网络属于一个广播域，当使用太多的交换机互联大量的主机时，就构成了一个打的广播域。如果网络广播域太大，广播域内任一主机发送的广播帧，其他所有主机都会收到。并且如果交换机存在环路，则广播帧就会被大量复制，从而产生广播风暴，消耗带宽，影响网络正常允许。 如何解决广播风暴呢？ 利用路由器将一个大的广播域分割为小的广播域。 广泛使用的技术就是虚拟局域网技术(VLAN)。 什么是虚拟局域网呢？ 一种基于交换机的逻辑分割广播域的局域网应用形式。以软件的方式划分和管理局域网中的工作组，限制接收广播信息的主机数。 如何划分虚拟局域网？ 基于交换机端口划分：每个交换机端口属于一个VLAN。 基于MAC地址划分：按主机MAC地址定义VLAN成员。 基于上层协议类型或地址划分：根据数据中的上层协议类型(IP)或者地址定义VLAN成员。 2.2 点对点链路协议 MAC协议是共享链路的，网络中还有一种是点对点的链路。这类链路大多用于广域网中，由于不存在介质共享的问题，所有这类的链路都不需要MAC协议。 点对点链路协议： 点对点协议(PPP协议) 高级数据链路控制协议(HDLC协议) 2.2.1 PPP协议主要提供3类功能： 成帧：确定一帧的开始和结束(以01111110字节开始，也以它结束)，支持差错检测。 链路控制协议(LCP): 启动线路、检测线路、协商参数、关闭线路。 网络控制协议：协商网络层选择。 当发送的数据中包含01111110这类特殊数据，就会进行字节填充一个特俗的控制转义字节01111101。 2.2.2 高级数据链路控制协议 HDLC有三种类型的帧(根据控制位的不同)： 信息帧(I格式) 管理帧(S格式) 无序号帧(U格式) HADL协议是面向位的协议：位填充技术 当数据字段出现与标志字段相同的比特流：10001111110010010，上述加粗的其实是普通数据，这就只能使用位填充技术进行处理。 发送端：发现5个连续的1，在其后插入0：100011111010010010接收端：发现5个连续的1，删除其后的0：100011111010010010 六、物理层1 数据通信基础 什么是信道？ 信道是信号传输的介质。狭义信道：指信号的传输介质。广义信道：不止是传输介质，还包括通信系统中的一些转换装置。 数据通信系统的构成：计算机网络是典型的数据通信系统。信源：叫消息转换成信号的设备(电话机、计算机)。发送设备：将信源产生的信号进行适当变换(编制、调制)的装置。信道：传输信号的媒介(有线、无线)接收设备：完成发送设备的反变换，即进行译码和解码。信宿：信号的终点，将信号转换位供人们识别的消息。噪声源：自然界和通信设备所固有的，对通信信号产生干扰的各种信号。 发送设备与接收设备是相互对应的，模拟通信与数字通信。发送设备发送的是模拟信号就是模拟通信系统，发送设备发送的是数字信号就是数字通信系统。 什么是模拟信号？ 值信号的因变量完全随连续消息的变化而变化的系号。自变量：可以连续的，可以离散的。因变量：一定连续的。电视图像信号、电话语言都是模拟信号什么是数字信号？是指消息的因变量是离散的，自变量的取值也是离散的信号。自变量：离散的。因变量：离散的。计算机数据、数字电话、数字电视都是数字信号。 数据的通信方式数据传输方向：单向通信：无线电广播双向交替通信(半双工)：对讲机。双向同时通信(全双工)：电话网、计算机。 数据传输时空顺序：并行通信：一个字节，每一位一个通道，全部位同时传送。串行通信：一条通道，每一位一次在这条通道传送。 数据同步技术：通信系统中实现收发两端动作统一，保持收发步调一致的过程。异步和同步技术本质上属于同步技术，区别在于收发端的时钟是独立的还是同步的。 异步通信：发送字符，不需要建立同步时钟，实现简单，传输效率低，适用于低俗网络。 同步通信：**发送数据块(包含多个字符)**，双方建立同步时钟，实现复制，传输效率高，适用于高速网络。 数据通信系统的功能： 信道的利用：多个通信设备共享，多路复用技术。 接口及信号产生：保证信源、信宿与传输系统之间的信息交互。 同步：发送与接收器之间达成约定。 差错检测与纠正：发现信号失真，并纠正。 寻址与路由：具有多条路径的网络选择合适的路径进行数据传输。 网络管理：规划、设置、监控、调度与维护。 安全保证：数据在传输过程中不被改变，不被非法用户获取。 2 物理介质 物理介质时网络中国传输信息的载体。 2.1 导引型传输介质（有线信道） 以导线为传输介质，信号沿导线进行传输，信号的能量集中。因此传输效率高，但是部署不灵活。 架空明线：平行且相互分离或绝缘的架空裸线线路（铜线或者铝线）优点：传输损耗较低。缺点：易受天气和外界电磁干扰。对外界噪声敏感。带宽有限。 双绞线：两根相互绝缘的铜线并排绞合在一起，可以减少对相邻导线的电磁干扰。模拟传输和数字传输皆可。主要用于基带传输。屏蔽双绞线（STP）：如图a，性能好。价格高，安装复杂非屏蔽双绞线（UTP）：如图b，局域网普遍使用。 UTP类别 带宽MHz 典型应用 3 16 低速网络，电话网络 4 20 10Base-T以太网 5 100 10Base-T以太网，100Base-T快速以太网 5E（超5类） 100 100Base-T快速以太网，1000Base-T千兆以太网 6 250 1000Base-T千兆以太网，ATM网络 同轴电缆：由同轴的两个导体构成，外导体（网状空心金属导体）和内导体（铜线），两者之间是绝缘实心介质。 主要用于频带传输。在有线电视网络应用广泛。 按照光纤内光波传输模式的不同：单模光纤和多模光纤。光纤与其他介质相比的优点： 光纤通信容量非常大，最高可达100Gbit&#x2F;s。 传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好，也不易被窃听或截取数据。 体积小，重量轻。 2.2 非导引型传输介质地波传播频率表较低、2MHz以下沿地球表面传播传播距离超过数百米或数千千米 天波传播：传输频率：2-30MHz距离地表：60-400km 视线传播频率：高于30MHz电离层之上 3 信道与信道容量 什么是信道？ 信道就是信号在通信系统中传输的通道。无线通信：信道就是电磁波传输通过的空间。有线通信：信道就是导向型线缆。 信道的分类：狭义信道：信道传输介质。**广义信道(简称信道)**：包括信号传输介质和通信系统的一些变换装置(发送设备、接收设备、天线、调制器等). 广义信道按功能分：调制信道、编码信道。 什么是调制信道？ 变为连续的模拟信号。调制信道：“模拟信道”。从调制器的输出端传输到解调器的输入端经过的部分。 调制信道有什么特点？ 信道总具有输入信号端和输出信号端。 信道一般是线性的，输入信号和输出信号之间的线性叠加原理。 信道是因果的，输出信号响应具有延时。 信号发生畸变，输出信号发生衰减。 噪声，输入信号为零，输出信号也具有一定功率。 调制信道又分为随参信道和恒参信道。 随参信道：信号通过信道发生的畸变是时变的,存在多径传播现象，称为随机参数信道。 恒参信道：畸变与时间无关，称为恒定参数信道。例如：架空明线、电缆、波导、卫星中继等等属于恒参信道，其他介质属于随参信道。 什么是编码信道？ 编码：变成数字信号。编码信道：数字信道。数字信号由编码器输出端传输到译码器输入端经过的部分。包括调制信道调制器、解调器。 graph LR; A((信源)) --> B[编码器]--> C[调制器] subgraph 编码信道 C--> D[发射设备]-->E{传输介质}-->F[接收设备]-->G[解调器] end G-->H[译码器]-->J((信宿)) 编码信道又分为无记忆编码信道、有记忆编码信道 无记忆编码信道：发生错误的码元是相互独立的，当前码元的差错与前后码元没有依赖关系。 有记忆编码信道：发生错误的码元不是相互独立的，当前码元的差错与前后码元有联系。 信道的传输特性在很大程度上决定了信道的传输性能，如带宽、传输速率、信道容量等。 1）信道的带宽：是指能够有效通过该信道的信号的最大频带宽度、用码元速率（或符号速率）描述，单位是Baud。2）传输速率：是信道单位时间内传输的码元元（或符号）或信息的能力、用传信率（或信息速率）来描述，单位是bit&#x2F;s。3）信道容量：信道无差错传输信息的最大平均信息速率。衡量信道的传输能力。 如何计算连续性信道容量？奈奎斯特理想的，无噪声的信道容量。C&#x3D;2Blog₂M。C信道容量，单位是bit&#x2F;s。B信道带宽，单位为Hz。M进制数，即信号状态数香农公式给出的连续信道的信道容量：C&#x3D;B1og₂(1+S&#x2F;N)。C信道容量，单位是bit&#x2F;s。B信道带宽，单位为Hz。S&#x2F;N信噪比，分贝（dB）为单位，信号功率与噪声功率之比。 信噪比换算公式:$$(S&#x2F;N){dB}&#x3D;10log{10}(S&#x2F;N)_{功率}$$ 示例：知某信道带宽为8kHz，信噪比为30dB试求该信道的信道容量C。$$\\displaylines{解：因为(S&#x2F;N){dB}&#x3D;30dB,所以(S&#x2F;N){功率}&#x3D;1000 \\ C&#x3D;Blog_{2}(1+S&#x2F;N)&#x3D;8\\times10^{3}log_{2}(1+1000)\\cong80kbit&#x2F;s}$$ 4 基带传输模拟信源：电话机发出，可以通过信源编码转换为数字基带信号；数字信源：计算机发出。数字信号两种传输方式：基带传输频带传输。 基带信号：信源发出的没有经过调制的原始信号。基带传输：直接在信道传送基带信号。相应的系统称为基带传输系统。数字基带传输：直接在信道中传输数字基带信号。相应的系统称为数字基带传输系统。 数字基带传输系统结构： graph LR; B((数字基带信号))-->C[信号形成器]-->A[信道]-->D[接收过滤器]--同步提取-->E[抽样判决器]-->F((再生数字基带信号)) G((噪声))-->A 信号形成器：把原始数字基带信号变换成更适合在信道上传输的数字基带信号。接受过滤器：过滤掉噪声。同步提取和抽样判决器两者相互合作，再生数学基带信号。 数字基带信号码有很多种，常见的是利用矩形脉冲信号的幅值编码二进制数字数据（即将二进制数字数据映射成脉冲信号）。 单极不归零码 双极不归零码 单极归零码 双极归零码 差分码（相对码） 单极和双极： “单极”：脉冲幅值要么是正电平要么是零电平，只有一个极性。 “双极”：脉冲值有正电平，也有负电平，两个极性。 归零和不归零： “不归零”：在脉冲持续时间内，电平保持不变，且脉冲持续期结束时不要求必须回归0电平。 “归零”：每个脉冲持续期的中间时刻，电平（正、负）要回到0电平。 示例：1100100111单极不归零NRZ：数字0：零电平表示数字1：正电平表示。 双极不归零：数字0：负电平表示数字1：正电平表示。 单极归零码RZ：数字0：零电平表示数字1：正电平表示。且脉冲持续时间中间时刻回归到零电平。 双极归零码： 差分码(相对码)：数字1：相邻电平有跳变^8。数字0：相邻电平无跳变。 数字基带信号的基本码型变换为适合传输的数字传输基带传输码。 AMI码 双相码 米勒码 CMI码 nBmB码 nBmT码 AMI码：信号交替反转码(Alternative Mark Inversion)编码规则：用3种电平平（正电平、负电平、零电平）进行编码0：零电平表示1：交替用正电平（+1：正脉冲）和负电平（-1负脉冲）表示示例：100001000011000011—&gt;+10000-10000+1-10000+1-1 双相码（Biphase Code），又叫曼彻斯特（Manchester）码。只有正负电平，脉冲持续时间的中间时刻都要进行电平跳变。数字1：一个脉冲时间内从正电平跳到负电平数字0：一个脉冲时间内从负电平跳到正电平示例：1100101101 双相码（BiphaseCode）的另一种码型：差分双相码（差分曼彻斯特码）1：相邻电平有跳变0：相邻电平无跳变示例：1100101101 米勒码（MillerCode）：一种双相码的变形，也称延迟调制码。1：双极非零码的01（负正）或者10（正负）。连1：后面的1交替编码（前面的1是01，后面的1就是10，反之亦然）0：双极非零码的00或者11，码元中间不跳变。单个0：其前沿、中间时刻、后沿均不跳变。连0：两个0码元的间隔跳变（前一个0的后沿，后一个0的前沿）示例：1100101101 4）传号反转码（Coded Mark Inversion，CMI码）将信息码的一位映射成双极不归零的2位。数字1：正（11）、负（00），交替编码。数字0：一个脉冲时间内从负电平到正电平06（01）。示例： nBmB码将n位二进制信息码作为一组，映射成m位二进制新码组，m&gt;n。快速以太网采用的是4B5B。 nBmT码将n位二进制信息码作为一组，映射成m位三进制新码组，m&#x3D;n。例如：4B3T，8B7T等。 注解引用","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"zk-todo","slug":"zk-todo","permalink":"https://news-epoch.github.io/tags/zk-todo/"},{"name":"booknote","slug":"booknote","permalink":"https://news-epoch.github.io/tags/booknote/"},{"name":"计算机","slug":"计算机","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"基础学科","slug":"基础学科","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"}]},{"title":"丢包率","slug":"丢包率","date":"2022-10-29T12:43:01.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/10/29/丢包率/","permalink":"https://news-epoch.github.io/2022/10/29/%E4%B8%A2%E5%8C%85%E7%8E%87/","excerpt":"","text":"从源网络设备发出N个数据包，在宿网络设备接收到N-n个数据包，其中在传输过程中丢失的数据包占总数据包的百分比 .反映了链路的阻塞程度。 NS：为发送分组总数Nr：接收分组总数Nl：丢失分组总数","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"时延带宽积","slug":"时延带宽积","date":"2022-10-29T12:43:01.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/10/29/时延带宽积/","permalink":"https://news-epoch.github.io/2022/10/29/%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF/","excerpt":"","text":"是指一段物理链路的传播时延与带宽的乘积,即是距离，可以用来表示在单条链路上可以存放的数据位数，","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"SaaS平台","slug":"SaaS平台","date":"2022-10-29T12:43:00.000Z","updated":"2025-07-02T09:53:10.797Z","comments":true,"path":"2022/10/29/SaaS平台/","permalink":"https://news-epoch.github.io/2022/10/29/SaaS%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"SaaS,是Software-as-a-Service的缩写，通过网络提供软件服务，SaaS平台供应商将应用软件同意部署在自己的服务器上，客户可以根据工作实际需求，通过互联网想厂商订购所需的应用软件服务，按订购时间的长短和服务多少像厂商支付费用","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"laaS平台","slug":"laaS平台","date":"2022-10-29T12:43:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/10/29/laaS平台/","permalink":"https://news-epoch.github.io/2022/10/29/laaS%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"laaS主要一种提供虚拟计算、存储、数据库等基础设施服务的商业模式","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"吞吐量","slug":"吞吐量","date":"2022-10-29T12:43:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/10/29/吞吐量/","permalink":"https://news-epoch.github.io/2022/10/29/%E5%90%9E%E5%90%90%E9%87%8F/","excerpt":"","text":"单位时间内，从源主机到宿主机的实际到达量。注意：吞吐量会受到网络链路带宽、网络复杂性、网络协议、网络拥塞程度影响。在分组交换网络中，吞吐量约等于瓶颈链路的带宽，即，三段链路中的最小带宽。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"时延","slug":"时延","date":"2022-10-29T12:43:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/10/29/时延/","permalink":"https://news-epoch.github.io/2022/10/29/%E6%97%B6%E5%BB%B6/","excerpt":"","text":"可以有结点时延、排队时延、传播时延、传输时延。表示从一个网络结点(网络设备)到另一个网络结点(网络设备)所需要的时间 结点处理时延dc：单位时间内，交换设备检查分组是否有差错，确定如何转发分组的时间。 排队时延dq：单位时间内，交换设备中数据包从排队开始到输出链路发送到下一个结点的排队时间。 传输时延dt：单位时间内，信号在实际链路中传播时间(第一位从链路开始到最后一位完全进入链路的发送时间)—&gt;分组长度L&#x2F;信号传播**最大速率(带宽)**R 传播时延dp：信号从发送端出来，经过一段物理链路到达接受端所需要的时间。dp&#x3D;D(物理链路长度)&#x2F;V(传播速度)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"速率","slug":"速率","date":"2022-10-29T12:43:00.000Z","updated":"2025-07-02T09:53:10.799Z","comments":true,"path":"2022/10/29/速率/","permalink":"https://news-epoch.github.io/2022/10/29/%E9%80%9F%E7%8E%87/","excerpt":"","text":"单位时间内，源主机向宿主机发送的最大比特数，用来描述网络传输数据的快慢。单位：bit&#x2F;s 1Kbit&#x2F;s&#x3D;1000bit&#x2F;s&#x3D;10^3bit&#x2F;s1Mbit&#x2F;s&#x3D;1000000bit&#x2F;s&#x3D;10^6bit&#x2F;s1Gbit&#x2F;s&#x3D;1000000000bit&#x2F;s&#x3D;10^9bit&#x2F;s1Tbit&#x2F;s&#x3D;1000000000000bit&#x2F;s&#x3D;10^12bit&#x2F;s","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"}]},{"title":"可变类型字符StringBuilder与StringBuffer","slug":"可变类型字符StringBuilder与StringBuffer","date":"2022-04-12T04:00:00.000Z","updated":"2025-07-02T09:53:10.798Z","comments":true,"path":"2022/04/12/可变类型字符StringBuilder与StringBuffer/","permalink":"https://news-epoch.github.io/2022/04/12/%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E5%AD%97%E7%AC%A6StringBuilder%E4%B8%8EStringBuffer/","excerpt":"","text":"正文内容1 为什么抛弃String而使用StringBuilder与StringBuffer1234String str=&quot;abc&quot;;System.out.println(str);str=str+&quot;de&quot;;System.out.println(str); 如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 2 StringBuilder、StringBuffer有什么区别 StringBuilder 是不安全线程，效率高 StringBuffer 是安全线程 但是效率低 AbstractStringBuilder都是他们的父类 都是以char类型进行数据存储，且默认长度都是16 2.1 常用方法 append delete setCharAt() deleteCharAt(); indexOf() lastIndexOf() insert 3 底层分析12345678910title: 分析下列代码底层运行情况collapse: open```JavaString s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; String s3 = s1+s2;```其中 s1和s2变量 先在栈空间进行创建，然后再常量池中创建hello和world值并通过地址指向栈空间，然后，因为s3 = s1+s2 所以会在**堆空间中创建StringBuilder对象**\\[String s3 = new StringBuilder()]，并调用append方法进行添加s1和s2 4 使用场景 2.引用知乎上的一个回复作者：小猪链接：https://www.zhihu.com/question/20101840/answer/164866159来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 我不知道为什么这个这么老的问题会出现在我的时间线上，看了一下回答，大多是2012，2013年的回答，照说那个年代，有些历史故事还很新鲜，却不知道为什么没有一个答案说到点子上。 stringbuffer固然是线程安全的，stringbuffer固然是比stringbuilder更慢，固然，在多线程的情况下，理论上是应该使用线程安全的stringbuffer的。 然而，然而，然而，有谁给我一个实际的案例来显示你需要一个线程安全的string拼接器？对不起，至少在我浅薄的十几年编程生涯中还没有遇到过，也许，仅仅是也许，这个地球上的确是存在这样的编程需求的，然而，它至少跟99.99…99%的程序员是无关的。所以，对于题主的问题，他们的适用场景是什么?最简单的回答是，stringbuffer基本没有适用场景，你应该在所有的情况下选择使用stringbuiler，除非你真的遇到了一个需要线程安全的场景，如果遇到了，请务必在这里留言通知我。 然后，补充一点，关于线程安全，即使你真的遇到了这样的场景，很不幸的是，恐怕你仍然有99.99…99%的情况下没有必要选择stringbuffer，因为stringbuffer的线程安全，仅仅是保证jvm不抛出异常顺利的往下执行而已，它可不保证逻辑正确和调用顺序正确。大多数时候，我们需要的不仅仅是线程安全，而是锁。 最后，为什么会有stringbuffer的存在，如果真的没有价值，为什么jdk会提供这个类？ 答案太简单了，因为最早是没有stringbuilder的，sun的人不知处于何种愚蠢的考虑，决定让stringbuffer是线程安全的，然后大约10年之后，人们终于意识到这是一个多么愚蠢的决定，意识到在这10年之中这个愚蠢的决定为java运行速度慢这样的流言贡献了多大的力量，于是，在jdk1.5的时候，终于决定提供一个非线程安全的stringbuffer实现，并命名为stringbuilder。顺便，javac好像大概也是从这个版本开始，把所有用加号连接的string运算都隐式的改写成stringbuilder，也就是说，从jdk1.5开始，用加号拼接字符串已经没有任何性能损失了。 ———–补充一个小小的修改———-如诸多评论所指出的，我上面说，”用加号拼接字符串已经没有任何性能损失了”并不严谨，严格的说，如果没有循环的情况下，单行用加号拼接字符串是没有性能损失的，java编译器会隐式的替换成stringbuilder，但在有循环的情况下，编译器没法做到足够智能的替换，仍然会有不必要的性能损耗，因此，用循环拼接字符串的时候，还是老老实实的用stringbuilder吧。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://news-epoch.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"计算机_程序语言_中间件","slug":"计算机-程序语言-中间件","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"计算机_操作系统_Linux","slug":"计算机-操作系统-Linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux/"},{"name":"计算机_操作系统_linux","slug":"计算机-操作系统-linux","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-linux/"},{"name":"WireGuard","slug":"WireGuard","permalink":"https://news-epoch.github.io/tags/WireGuard/"},{"name":"计算机_程序语言_Java_框架_Mybatis","slug":"计算机-程序语言-Java-框架-Mybatis","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E6%A1%86%E6%9E%B6-Mybatis/"},{"name":"计算机_程序语言_Java_基础","slug":"计算机-程序语言-Java-基础","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java-%E5%9F%BA%E7%A1%80/"},{"name":"名词","slug":"名词","permalink":"https://news-epoch.github.io/tags/%E5%90%8D%E8%AF%8D/"},{"name":"计算机_程序语言_编程思想_并发编程","slug":"计算机-程序语言-编程思想-并发编程","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"知识管理","slug":"知识管理","permalink":"https://news-epoch.github.io/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"},{"name":"基础学科_英语","slug":"基础学科-英语","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91-%E8%8B%B1%E8%AF%AD/"},{"name":"计算机_程序语言_Java","slug":"计算机-程序语言-Java","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA-%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80-Java/"},{"name":"zk-todo","slug":"zk-todo","permalink":"https://news-epoch.github.io/tags/zk-todo/"},{"name":"booknote","slug":"booknote","permalink":"https://news-epoch.github.io/tags/booknote/"},{"name":"计算机","slug":"计算机","permalink":"https://news-epoch.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"基础学科","slug":"基础学科","permalink":"https://news-epoch.github.io/tags/%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"},{"name":"效率_工具","slug":"效率-工具","permalink":"https://news-epoch.github.io/tags/%E6%95%88%E7%8E%87-%E5%B7%A5%E5%85%B7/"}]}